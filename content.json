{"pages":[{"title":"","text":"个人介绍 本科在读 喜欢写一些归纳类的文章 联系方式 邮箱：vuebee@163.com","link":"/about/index.html"},{"title":"基础编程模型","text":"1. 原始数据类型与表达式原始数据类型 &ensp;8 位整数，byte 16 位整数，short 32 位整数，int 64 位整数，long 16 位字符，char 32 位单精度实数，float 64 位双精度实数，double 表达式 Java 中使用 中缀 表达式，即：运算符在字面量或表达式之间。 逻辑运算符中 ! 拥有最高优先级，之后是 &amp;&amp;，然后是 ||。 2. 语句 声明语句：Java 是强类型语言，编译器会检查类型的一致性。 赋值语句：左侧必须是单个变量，右侧是能够得到相应类型的任意表达式。 条件语句：不同操作来处理不同的输入，分为 if 语句和 switch 语句。 循环语句：主要是 while 语句和 for 语句，循环语句中的代码称为循环体。 调用和返回语句：与静态方法有关，是执行流程和代码组织的另一种方式。 其他语句 break 语句：退出循环。 continue 语句：立即开始下一轮循环。 return 语句：返回值。 3. 数组 对于数组 a[]，程序可以通过 a.length() 获取数组长度。 可能出现的异常 ArrayIndexOutOfBoundsException 数组别名当我们将一个数组变量赋给另一个变量，那么两个变量都会指向同一个数组。 int[] a = new int[N];a[i] = 123;int[] b = a;b[i] = 456;System.out.print(a[i]); // 此处输出 a[i] 的值为 456 4. 静态方法静态方法是一组在被调用时会被顺序执行的语句，拥有修饰符 static，区别于实例方法。 方法的性质 方法的参数按值传递：方法中使用的参数变量可以引用调用者的数组并改变其内容，但不能改变与原数组变量本身（值传递）。也就是在方法中改变一个参数变量的值对调用者本身没有影响。 方法名可以被重载：例如同名方法可以传入多种参数类型。 方法只能返回一个值，但可以包含多个返回语句：返回被执行语句中第一条返回语句的参数。 方法可以产生副作用：void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或改变系统状态）。 递归方法可以调用自己；递归代码比相应的非递归代码更加简洁优雅、易懂。 最简单的情况：方法的第一条语句总是一个包含 return 的条件语句。 递归的调用总是去尝试解决规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。 // 二分查找的递归实现public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1);}public static int rank(int key, int[] a, int lo, int hi) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; }} 基础编程模型Java 开发的基本模是编写一个静态方法库（包含一个 main() 方法）来完成一个任务。 模块化编程我们可以构造许多个静态方法库（模块），一个库中的静态方法也可以调用另一个库中定义的静态方法。这能够带来很多好处： 程序整体的代码量很大时，每次处理的模块大小仍然适中； 可以共享和重用代码而无需重新实现； 很容易用改进的实现替换旧的实现； 可以为解决编程问题建立合适的抽象模型； 缩小测试范围。 单元测试每一个静态方法库中都包含一个 main() 函数来测试库中的所有方法（有些编程语言不支持多个 main() 方法，所以不支持这种方式）。我们可以将 main() 方法作为一个开发用例，在开发过程中用它来测试更多的细节；也可以将它编写成一个测试用例来对所有代码进行一个全面的测试。当用例越来越复杂，我们可能会将它独立成一个模块。 外部库 系统标准库 java.lang.*：包括实现了常用数学函数的 Math 库以及其他。 导入的系统库，例如 java.util.Arrays：需要在程序的开头使用 import 语句导入。 5. API模块化编程的一个重要组成部分就是记录库方法的用法并提供其他人参考的文档；我们应该将自己编写的每一个程序都当作一个日后可以重用的库。关于 API 的说明可参考 什么是 API ？ 6. 输入输出重定向与管道重定向将程序的输出重定向至一个文件： % java RandomSeq 1000 100.0 200.0 &gt; data.txt 重定向标准输入使从文件中读取数据： % java Average &lt; data.txt 管道将一个程序的输出重定向为另一个程序的输入叫做管道： % java RandomSeq 1000 100.0 200.0 | java Average 突破了能够处理的输入输出流的限制 运行的先后顺序由操作系统决定 7. 白名单过滤信用卡公司的例子： 将客户账号保存在一个文件中，称为白名单； 从标准输入中得到每笔交易的账号； 使用测试用例在标准输出中打印所有与客户无关的账号，公司很可能拒绝此类交易。 % java BinarySearch tinyW.txt &lt; tinyT.txt 此处的 tinyW.txt 就是一个白名单。 知识点+ Java 中一个静态方法不能作为另一个静态方法的参数，但在一些其他语言中可以。 习题见 习题 1-1","link":"/independent-pages/list/algs4/1/1.1/index.html"},{"title":"习题 1-1","text":"知乎上有一篇总结的还不错, 如果觉得不够详细，或者想要参考题目以及其他答案的同学，可以在 这里 找到。 练习1. 表达式的值&emsp;a. 7&emsp;b. 200.0000002&emsp;c. true 2. 类型和值&emsp;a. double, 1.618&emsp;b. double, 10.0&emsp;c. boolean, true&emsp;d. String, 33 3. equal 判断import java.util.Scanner;public class Test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); if (a == b &amp;&amp; b == c) { System.out.println(\"equal\"); } else { System.out.println(\"not equal\"); } }} 4. 语句修正if (a &gt; b) c = 0; else b = 0; 5. 范围判断import java.util.Scanner;public class Test { public static boolean right(double d) { if (d &gt;= 0.0 &amp;&amp; d &lt;= 1.0) { return true; } else { return false; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); double x = sc.nextDouble(); double y = sc.nextDouble(); if (right(x) &amp;&amp; right(y)) { System.out.println(\"true\"); } else { System.out.println(\"false\"); } }} 6. Fibnonacci 数列// 斐波那契数列的非递归算法int f = 0;int g = 1;for (int i = 0; i &lt;= 15; i++) { System.out.println(f); f = f + g; g = f - g;} 结果01123581321345589144233377610 7. 打印的值&emsp;a. 3.00009&emsp;b. 499500&emsp;c. 10000 8. 打印结果&emsp;a. b&emsp;b. 197&emsp;c. e 9. 正整数二进制 Java 中有内置方法 Integer.toBinaryString(); // 一个简洁的实现方法String s = \"\";for (int n = N; n &gt; 0; n /= 2) { s = (n % 2) + s;} 10. 代码存在的问题没有用 new 为 a[] 分配内存，会产生一个 variable a might not have been initialized 的编译错误。 int[] a;for (int i = 0; i &lt; 10; i++) { a[i] = i * i;} 11. 打印二维布尔数组// 已初始化 boolean 类型二维数组 bfor (boolean[] booleans : b) { System.out.print(lineNumber++ + \"| \"); for (boolean aBoolean : booleans) { if (aBoolean) { System.out.print(\"*\"); } else { System.out.print(\" \"); } } System.out.println();} 12. 打印结果此处书中有误，代码段应为： int[] a = new int[10];for (int i = 0; i &lt; 10; i++) a[i] = 9 - i;for (int i = 0; i &lt; 10; i++) a[i] = a[a[i]];for (int i = 0; i &lt; 10; i++) System.out.println(i); 结果0123443210 13. 二维数组的转置// 使用 int 类型数组举例，已初始化数组 a[M][N]int[][] temp = new int[N][M];for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][j] = a[j][i]; System.out.print(temp[i][j] + \" \"); } System.out.println();} 14. 返回不大于 log₂N 的最大整数public static int lg(int N) { int result = 0; int temp = 2; while (temp &lt; N) { temp *= 2; result++; } return result;} 15. 返回长度为 M 的数组public static int[] histogram(int[] a, int M) { int[] temp = new int[M]; for (int i = 0; i &lt; M; i++) { for (int value : a) { if (i == value) temp[i]++; } } return temp;} 16. exR1(6) 的返回值311361142246 17. 递归函数的问题这段代码中的基础情况永远不会被访问。调用 exR2(3) 会产生调用 exR2(0)、exR2(-3) 和 exR2(-6)，循环往复直到发生 StackOverflowError。 18. 考察乘法与乘方的递归实现 修改前： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a + a, b / 2); return mystery(a + a, b / 2) + a;} 返回值 mystery(2, 25) = 50mystery(3, 11) = 33mystery(a, b) = a * b 核心思想： x * y = (x * 2 * 2 * ...) * (y / 2 / 2 / ...)PS: 此处的 x 可能为偶数，但 y 必为奇数。 修改后： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a * a, b / 2); return mystery(a * a, b / 2) * a;} 返回值 mystery(2, 25) = 33554432mystery(3, 11) = 177147mystery(a, b) = aᵇ 核心思想： x ^ y = (x ^ 2) ^ (y / 2) 19. 改进 F(N) 的实现书上的递归方法探究一小时之内能够得到 F(N) 结果最大的 N 值因为耗时比较长这里就不做尝试了。改进的方法可以参考 6 中的 斐波那契数列的非递归算法 ，下面的是按书上要求利用数组保存值的改进方法： public static long F(int N) { int[] a = new int[N]; a[0] = 0; a[1] = 1; for (int i = 2; i &lt; N; i++) { a[i] = a[i - 1] + a[i - 2]; } return a[N - 1];} 20. ln(N!) 的递归求解public static double ln(int N) { if (N == 0 || N == 1) { return; } else { return ln(N - 1) + Math.log(N); }} 21. 输入数据打印表格这里用到了 printf() 的格式化输出，不懂的同学请自行参考 菜鸟教程 。 System.out.print(\"Please input data count: \");Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();String[] nameArray = new String[n];int[] integerArray1 = new int[n];int[] integerArray2 = new int[n];for (int i = 0; i &lt; n; i++) { nameArray[i] = scanner.next(); integerArray1[i] = scanner.nextInt(); integerArray2[i] = scanner.nextInt();}System.out.println(\"|----------|-----|-----|-----|\");for (int i = 0; i &lt; n; i++) { System.out.printf(\"|%-10s|%-5d|%-5d|%.3f|\\n\", nameArray[i], integerArray1[i], integerArray2[i], ((double) integerArray1[i] / integerArray2[i])); System.out.println(\"|----------|-----|-----|-----|\");} 看到有一个比较有意思的解题方法，思路是用 split() 方法将得到的两行数据进行拆分。缺点是如果输入的数据不是以单个空格为间隔就会报 NumberFormatException 的异常。 Scanner sc = new Scanner(System.in);String[] a = new String[2];int index = 0;while (index &lt; a.length) { a[index] = sc.nextLine(); index++;}for (String s : a) { String[] stringArr = s.split(\" \"); int num1 = Integer.parseInt(stringArr[1]); int num2 = Integer.parseInt(stringArr[2]); System.out.printf(\"%-10s%-5d%-5d%.3f\\n\", stringArr[0], num1, num2, ((double) num1 / num2));} 22. BinarySearch-按递归深度缩进如果你忘记了之前的 rank() 方法，可以在 这里 找到它。下面来对它进行改写： public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1, 1);}// 如果是在某一限定范围内进行查找，则需要手动传入参数 `deep` 的值// `deep` 的值需要设定在大于等于 1 的整数群中，否则在第 3 - deep 行中才会出现缩进效果public static int rank(int key, int[] a, int lo, int hi, int deep) { // 实现缩进 for (int i = 1; i &lt; deep; i++) { System.out.print(\" \"); } System.out.printf(\"%d. lo: %d hi: %d\\n\", deep, lo, hi); // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1, deep + 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi, deep + 1); } else { return mid; }} 23. BinarySearch 的测试用例public static void main(String[] args) { int[] whiteList = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.print(\"Please input \\\"+\\\" or \\\"-\\\": \"); // 为避免读入多余字符使用了 edu.princeton.cs.algs4 包中 StdIn 类里的 readChar() 方法 char flag = StdIn.readChar(); // 读入第一个字符以外的其余字符（不作用途） StdIn.readLine(); System.out.print(\"Please input keys(Split with space): \"); String[] keyList = StdIn.readLine().split(\" \"); for (String s : keyList) { if (flag == '+') { if (rank(Integer.parseInt(s), whiteList) == -1) { System.out.printf(\"%s \", s); } } else if (flag == '-') { if (rank(Integer.parseInt(s), whiteList) != -1) { System.out.printf(\"%s \", s); } } } System.out.println(\"\\nDone!\");} 24. 欧几里得算法计算最大公约数public class Euclid { public static int euclid(int p, int q) { if (q == 0) { return p; } System.out.printf(\"p = %d, q = %d\\n\", p, q); // 交换值的目的是为了减小递归的运算次数 if (p &lt; q) { int temp = p; p = q; q = temp; } return euclid(q, p % q); } public static void main(String[] args) { int p = StdIn.readInt(); int q = StdIn.readInt(); System.out.println(\"\\nresult = \" + euclid(p, q)); }} 25. 数学归纳法证明欧几里得算法参考：&emsp;简书 - 欧几里得算法心得(辗转相除法)&emsp;百度文库 - 辗转相除法的证明","link":"/independent-pages/src/algs4/1/1.1/index.html"}],"posts":[{"title":"《算法（第4版）》知识点归纳","text":"这篇博客主要来记录自己在书中总结归纳的知识点，来帮助自己更好地记忆书中的内容，并在复习时有一个可以参考的大纲。我在每个小节的后面也有附上习题的解答（因为想要加快一下学习进度，所以目前只提供练习题的解题步骤，后期会对提高题以及实验题进行补充）。部分解题代码用到了书中提供的类库，VS Code、 IDEA 等编辑器或编译器内置了快捷跳转至源码位置的操作，读者可以根据自身情况进行参考。另附本书配套的 在线 API 文档 、源码 ，以及下载链接 algs4.jar 、algs4-data.zip 。 部分习题答案是可以在 官网 上找到的。另外在 GitHub 上有一个分享自己解题代码的仓库，很详细，值得参考，见 Algorithms 。 PS: 本文中的大部分内容来自于《算法（第4版）》一书，想要了解的同学可以参阅 豆瓣读书 ，另见 英文版 。 第 1 章&emsp;基 础&emsp;&emsp;1.1&emsp;基础编程模型&emsp;&emsp;1.2&emsp;数据抽象&emsp;&emsp;1.3&emsp;背包、队列和栈&emsp;&emsp;1.4&emsp;算法分析&emsp;&emsp;1.5&emsp;案例研究：union-find 算法 第 2 章&emsp;排 序&emsp;&emsp;2.1&emsp;初级排序算法&emsp;&emsp;2.2&emsp;归并排序&emsp;&emsp;2.3&emsp;快速排序&emsp;&emsp;2.4&emsp;优先队列&emsp;&emsp;2.5&emsp;应用 第 3 章&emsp;查 找&emsp;&emsp;3.1&emsp;符号表&emsp;&emsp;3.2&emsp;二叉查找树&emsp;&emsp;3.3&emsp;平衡查找树&emsp;&emsp;3.4&emsp;散列表&emsp;&emsp;3.5&emsp;应用 第 4 章&emsp;图&emsp;&emsp;4.1&emsp;无向图&emsp;&emsp;4.2&emsp;有向图&emsp;&emsp;4.3&emsp;最小生成树&emsp;&emsp;4.4&emsp;最短路径 第 5 章&emsp;排 序&emsp;&emsp;5.1&emsp;字符串排序&emsp;&emsp;5.2&emsp;单词查找树&emsp;&emsp;5.3&emsp;子字符串查找&emsp;&emsp;5.4&emsp;正则表达式&emsp;&emsp;5.5&emsp;数据压缩 第 6 章&emsp;背 景&emsp;&emsp;6.0&emsp;背景","link":"/algs4/"},{"title":"Emacs Note","text":"这是一个 Emacs 的学习笔记，用来记录一些重要的知识点，以便于帮助自己进行回顾。笔记的大部分内容来自于 Spacemacs Rocks 第二季 的课程。 参见：&emsp; &emsp; 子龙山人：Master Emacs in 21 Days&emsp; &emsp; 视频教程：优酷 &emsp; 百度网盘 &emsp; YouTube 在 Emacs 中使用 C-h t 打开 Emacs Tutorial ，完成官方教程 1. 基础操作常见的符号意义： C(trl) 在 Mac 上为 Control 键 M(eta) 在 Mac 上为 Option 键 s(uper) 在 Mac 上为 Command 键 S(hift) 光标的移动： C-f 为前移一个字符， f 代表 forward C-p 为上移至前一行， p 代表 previous C-n 为上移至下一行， n 代表 next C-a 为移至行首， a 代表 ahead C-e 为移至行尾， e 代表 end 常用的文件操作： C-x C-f 为打开目标文件 f 代表 find / file C-x C-s 为保存当前缓冲区（Buffer）， s 代表 save C-x C-e 快捷键就是按预先绑定好的方式执行命令相似的前缀命令还有 C-c、C-h 2. 内置功能 M-x linum-mode 开启编辑器内的行号显示 3. 学习 Elisp 基础阅读教程 Learn X in Y minutes ，或参见 中文版 ;; 2 + 3 * 4(+ 2 (* 3 4))(setq my-name \"Mark\")(message my-name)(defun my-func () ;; Specify a way of parsing arguments for interactive use of a function. (interactive) (message \"Hello, %s\" my-name))(global-set-key (kbd \"&lt;f2&gt;\") 'my-func) 4. 简单的编辑器自定义Emacs 的配置文件默认保存在 ~/.emacs.d/init.el 文件中，也可以保存在 ~/.emacs 文件中。 如果将配置放在 ~/.emacs.d/init.el 文件中，需要手动删除 ~/.emacs 文件。 ;; 关闭工具栏，tool-bar-mode 是一个 Minor Mode(tool-bar-mode -1);; 关闭文件滑动控件(scroll-bar-mode -1);; 显示行号(global-linum-mode 1);; 更改光标的样式(golbal-setq cursor-type 'bar);; 关闭启动帮助画面(setq inhibit-splash-screen 1);; 关闭缩进;; (electric-indent-mode -1);; 更改显示字体大小 16pt;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs(set-face-attribute 'default nil :height 160);; 快速打开配置文件(defun open-init-file() (interactive) (find-file \"~/.emacs.d/init.el\"));; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上(global-set-key (kbd \"&lt;f2&gt;\") 'open-init-file) 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加载配置文件。重新加载配置文件你需要在当前配置文件中使用 M-x load-file 双击两次回车确认默认文件名，或者使用 -x eval-buffer 去执行当前缓冲区的所有 Lisp 命令。 你也可以使用 C-x C-e 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效. 5. 插件管理使用默认的插件管理系统（在菜单栏 Options &gt; Manage Emacs Packages 中找到）安装 Company 插件，是一个用于代码补全的插件。它的名字代表补全一切的意思（ Comp lete Any thing）。 ;; 开启全局 Company 补全(global-company-mode 1) 6. Org-mode分级标题* 为一级标题** 为二级标题*** 为三级标题并以此类推 作为 GTD 工具进行时间管理C-c C-t 切换 TODO -&gt; DONE -&gt; NONE","link":"/emacs-note/"},{"title":"同一客户端下使用多个 Git 账号","text":"我们在日常使用 Git 进行文件管理时，避免不了会使用多个账号的情况。自己在家开发一些小项目就托管在 Github 上面，而在公司的话会用到另外一个账号，可能是 GitLab 账号进行管理，或者是自己想要搭建一个个人博客并托管在另一个账号，那么单纯的 HTTPS 就不足以支持两个账号在同一客户端进行使用了，这时就需要用到 SSH 来进行管理。 PS: 这篇博客主要是想要记录自己多个 Git 账号的配置过程，以备查阅。 1. 清除 Git 的全局设置git config --global --unset user.namegit config --global --unset user.email 2. 生成新的 SSH keys用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pubssh-keygen -t rsa -C \"new email\" 在生成第一组 id_rsa 和 id_rsa.pub_ 可以选用默认的文件名，在出现提示输入文件名的时候要输入一个不同的文件名，比如： 这里填的是 id_rsa_new Enter file in which to save the key (~/.ssh/id_rsa): id_rsa_new 注： Windows 用户和 Mac 用户的区别就是，mac 中 .ssh 文件夹在根目录下，所以表示成 ~/.ssh/，而 Windows 用户是 C:\\Users\\Administrator\\.ssh。 执行 ssh-agent 让 ssh 识别新的私钥因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中： ssh-add ~/.ssh/id_rsa_new 如果出现 Could not open a connection to your authentication agent 的错误，就试着用以下命令： ssh-agent bashssh-add ~/.ssh/id_rsa_new 3. 配置 ~/.ssh/config 文件# 该文件用于配置私钥对应的服务器Host git@github.com # 别名，随便定 后面配置地址有用 HostName https://github.com User git IdentityFile ~/.ssh/id_rsa # 密钥文件的地址，注意是私钥# second user(second@mail.com)Host git@code.xxxxxxx.com HostName https://code.xxxxxxx.com User git IdentityFile ~/.ssh/id_rsa_new PS: HostName 如果添加 https:// 前缀可能发生 public key 不能识别的情况，所以可以直接改为 github.com 4. 添加新的 SSH keys 到新账号的 SSH 设置中5. 测试一下$ ssh -T git@github.com # 此处是 Host 后面定义的别名Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.# 上面是 github 的成功返回语句，下面是 gitlab 的成功返回语句。$ ssh -T git@xxxxxx.comWelcome to GitLab, xxx! 链接：https://www.jianshu.com/p/89cb26e5c3e8/来源：简书 参考资料https://blog.csdn.net/onTheRoadToMine/article/details/79029331/ https://gist.github.com/suziewong/4378434/","link":"/git-one-more-account/"},{"title":"Hanoi 塔问题在 C++ 中的递归实现","text":"Hanoi 塔问题想必是很多同学在大一都会接触到的，它是一个很经典的算法问题，这里主要阐释 Hanoi 问题在 C++ 中的递归实现。当然你也可以查阅一些其他资料来理解它的非递归实现过程，这里就不再叙述了。有兴趣的同学可以参考：迭代式汉诺塔(利用栈实现非递归) &emsp; 汉诺塔问题的递归和非递归算法 本文意旨解决“为何圆盘的移动的位置不对？”的问题，用两组代码来分析圆盘的移动位置。 PS: 当然，如果想更好地理解这篇博客，就需要你在阅读之前对 Hanoi 塔问题有一个清晰的了解。如果你还不知道什么是 Hanoi 塔问题，请移步 百度百科。 开始分析1. 先来看一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 b 柱将圆盘全部移到 c 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucers: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 hanoi(n - 1, b, a, c); // 将第 n-1个圆盘从 b柱借助 a柱移动到 c柱} 如果你之前有成功实现过hanoi塔从 a 移动到 c (a ⟹ c) 的递归算法，应该很容易就能看懂。但是你试过将圆盘从 a 柱全部移动到 b 柱上的情况吗？ 如果你已经清楚了代码的含义，那么你可以试着实现另外的几种情况 a ⟹ b b ⟹ c c ⟹ a c ⟹ b 2. 再来看另一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 c 柱将圆盘全部移到 b 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucer: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 hanoi(n - 1, c, b, a); // 将第 n-1个圆盘从 c柱经由 a柱移动到 b柱} 你可能会觉得两组代码在实现上没什么差别，那我们来看两组代码其中一行的对照： hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 我们可以发现，两组代码中这一行代码都是相同的，但为什么实现的操作是不一样的呢？ 3. 其中两行代码的对比std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 我们可以看到第一行代码时从 a位置 指向 c位置，第二行代码则是从 a位置 指向 b位置， 而第一行代码中的 “a位置” 和 “c位置” 对应了第一组代码 hanoi(n - 1, a, c, b); 中的 c 和 b，第二行代码中的 “a位置” 和 “b位置”对应了第二组代码 hanoi(n - 1, a, c, b); 中的 c 和 b 整组代码中实现输出是依靠 输出流语句，所以 hanoi(n - 1, a, c, b); 中的字母顺序要根据 输出流语句 的变化而变化以达到正确调用递归的目的。 也是大一刚开始接触编程语言，希望我的分享能给大家带来帮助 (｡･∀･)ﾉﾞ 到这里如果你还没有弄明白，这里能以图的形式更直观地理解 Hanoi 塔问题的递归实现，请参考：汉诺塔的图解递归算法","link":"/hanoi-cpp/"},{"title":"关于 VS Code 中 \"Classpath is incomplete\" warning","text":"问题概述每当打开一个 java 文件时，它不属于项目（我们称之为独立的 java 文件），vscode-java 无法计算正确的类路径。它使报告编译错误变得毫无用处，因为 UI 会在整个文件中填充令人分心的红色错误，例如： 幸运的是，vscode-java 仍然能够为基本 JDK 类提供有用的内容辅助，报告语法错误，计算类大纲或允许代码导航。因此，显示以下警告： 如果您只是关闭消息，它将在下次打开独立的 java 文件时弹出。通过单击Don’t Show Again 选项，可以永久地丢弃该消息。 如果改变主意，可以在 VS Code 的用户设置中修改该选项：java.errors.incompleteClasspath.severity 键指定当 java 文件的类路径不完整时消息的严重性。支持的值包括 ignore, info, warning 和 error。 您需要打开一个包含 pom.xml, build.gradle 或至少是默认 eclipse 设置文件的文件夹，以便可以设置完整的类路径和项目层次结构。 Android 项目基于 Gradle 的 Android 项目目前显示此消息，因为目前不支持 Android 开发。这是 limitation of BuildShip，该项目提供 Gradle 支持。 参考：https://github.com/redhat-developer/vscode-java/wiki/%22Classpath-is-incomplete%22-warning","link":"/vscode-warning-classpath-is-incomplete/"},{"title":"Mac 上好用的 APP 整理","text":"我整理了一些自己平常在 Mac 上经常用到的 APP，大家可以参考一下。另外我提供了项目网站和下载页面的地址。 文本编辑：Atom Atom 是由 GitHub 专门为程序员推出的跨平台文本编辑器，支持 CSS，HTML，JavaScript 等网页编程语言。 Emacs Emacs 是被公认为程序员最喜爱的代码编辑器之一，另外一个是 Vim。Emacs 使用 Emacs Lisp 这种极具扩展性的编程语言，实现了包括编程、编译乃至网络浏览等功能的扩展。 Sublime Text 3 Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 MacDown MacDown 是一款 Mac 下的 Markdown 编辑器。由于 Mou 的作者曾宣布不再继续该软件的开发并寻求出售所有权，所以 Macdown 的作者决定自己开发，MacDown 的很大一部分受到了 Mou 的影响。 效率工具：Alfred Alfred 是 Mac 下最流行的提升效率的工具。 AppCleaner AppCleaner 是 macOS 上的超轻量卸载专家。 Magnet Magnet 是 macOS 上进行窗口管理的快捷工具。 Pock Pock 是一款 macOS App，你可以通过它把 Touch Bar 变成系统中的 Dock 栏，直接用来切换和启动 App。 QSpace QSpace 是一款简洁高效的多视图文件管理器。 Sip Sip 是 macOS 上一款非常不错的取色软件。 清理工具：Tencent Lemon Tencent Lemon 是 macOS 上的一款清理软件，在 AppStore 上提供 Lite 版本的下载。 播放器：IINA IINA 是一个现代的 macOS 视频播放器。 通讯：Telegram Telegram 是一款跨平台的实时通讯软件。 云盘：Mega Mega 是一款云储存服务，免费版账户提供 35G 的云储存空间。 Seafile Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。普通用户提供 2GB 的储存空间。 VPN 服务Windscribe Windscribe 是一款跨平台的 VPN 服务，普通用户每月有 10GB 的免费流量。","link":"/awesome-mac-apps/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"Emacs","slug":"Emacs","link":"/tags/Emacs/"},{"name":"Elisp","slug":"Elisp","link":"/tags/Elisp/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hanoi","slug":"Hanoi","link":"/tags/Hanoi/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"笔记","slug":"Java/笔记","link":"/categories/Java/笔记/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"开发工具","slug":"Git/开发工具","link":"/categories/Git/开发工具/"},{"name":"算法","slug":"C/算法","link":"/categories/C/算法/"}]}