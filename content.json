{"pages":[{"title":"","text":"个人介绍 本科在读 喜欢写一些归纳类的文章 联系方式 邮箱：vuebee@163.com","link":"/about/index.html"},{"title":"HTML5 基础","text":"从 HTML4 到 HTML5语法变化 省略了 &lt;html&gt;、&lt;head&gt;、&lt;body&gt; 等元素，简化 &lt;meta&gt; 元素的 charset 属性值，&lt;p&gt; 元素的结束标记。 文档类型声明简化为 &lt;!DOCTYPE html&gt; ，使用工具时可以加入 SYSTEM 识别符，声明方法：&lt;!DOCTYPE html SYSTEM &quot;about:legacy-cpmpat&quot;&gt; 。 简化了 charset 属性的写法：&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text.html&quot;; charset=&quot;UTF-8&quot;&gt;–&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; 标记省略… 在 标签省略之后可以使用 document.body 进行访问。 属性值在不写属性值时属性值才会为空。 属性值可以使用单双引&emsp;–&gt;&emsp;属性值不包括 “空串、&lt;、&gt;、-、单双引号” 时可以省略两边的引号 HTML4 属性核心属性： class：类规则或样式规则 id：元素的唯一标识 style：元素的样式声明 文档头部区域，定义网页元信息：html、head、title、base、meta、param、script、style 语言属性： lang：元素的语言代码或编码 dir：文本方向，包括 ltr 和 rtl 没有语言属性的元素：frameset、frame、iframe、br、hr、base、param、script 键盘属性： accesskey：访问某元素的键盘快捷键（Alt + 字母） tabindex：元素的 Tab 键索引编号（大小决定 Tab 键遍历顺序） 内容属性： alt：元素的替换文本 title：元素的提示文本 longdesc：元素包含内容的大段描述信息 cite：元素包含内容的引用信息 datetime：元素包含内容的日期和时间 替换属性： rel：当前页面与其他页面的关系（源文档 –&gt;目标文档，prev 属性代指平等关系） rev：其他页面与当前页面之间的链接关系（目标文档 –&gt; 源文档） HTML5 元素HTML5 中又添加了许多结构、功能和表单元素，后面随学随记，这里就不一一列出了。需要可以参考 HTML5 新元素 。 XHTML 文档格式中含有： &lt;!-- xmlns 属性声明文档命名空间 --&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;!-- 设置文档字符编码 --&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text.html\"; charset=\"gb2312\" /&gt; 基本语法：文档类型、设置 xmlns 属性、闭合标签、元素和属性必须小写、属性使用引号扩起来、所有属性必须赋值、 &lt;!-- 错误写法：&lt;td nowrap&gt; --&gt;&lt;!-- 没有值的属性使用自身来进行赋值 --&gt;&lt;td nowrap=\"nowrap\"&gt; name 属性被废除，使用 id 作为统一的名称（IE4.0 版本一下可以同时使用）","link":"/independent-pages/list/web/1/index.html"},{"title":"单向循环链表解决约瑟夫环问题 - Golang 实现","text":"问题描述编号为 1, 2, … , n 的 n 个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。一开始任选一个正整数作为报数上限值 m ，从第一个人开始按顺时针方向自 1 开始顺序报数，报到 m 时停止报数。报 m 的人出列，将他的密码作为新的 m 的值，从他在顺时针方向上的下一个人开始重新从 1 报数，如此下去，直至所有人全部出列为止。 基本要求利用单向循环链表存储结构模拟此过程，按照出列的顺序印出各人的编号。 测试数据7 个人的密码依次为：3, 1, 7, 2, 4, 8, 4 ；m 值为 6 （正确的出列顺序应为 6, 1, 4, 7, 2, 3, 5）。 开始单个结构体的实现 定义指针和结构体 package mainimport \"fmt\"// 定义结构体type Person struct { num int // 序号 code int // 密码 next *Person}var head, tail *Person // 分别指向 ring 的头和尾 添加操作 /* 向 ring 中添加一个编号为 num ，密码为 code 的人 */func (ring *Person) add_Jos(num int, code int) { current := &amp;Person{code: code, num: num} if head == nil { // 当 ring 中还没有人时，使 head 和 tail 指向 current head = current current.next = head tail = current } else { // 将 current 作为 ring 的尾巴，设定 current.next 为 head tail.next = current current.next = head tail = current }} 移除操作 /* 移除报到 code 的人，打印出这个人的序号并返回他的密码 */func (ring *Person) remove_Jos(code int) int { if code == 1 { // 当要移除的人是 head 指向的人时 code = head.code fmt.Printf(\"%d \", head.num) head = head.next tail.next = head // head 的指向改变，重新设定 tail.next 为 head return code } // 当要移除的人不是 head 指向的人时 for i := 0; i &lt; code-2; i++ { // 使 head 指向需要移除的人的前一个人 head = head.next } code = head.next.code fmt.Printf(\"%d \", head.next.num) tail = head // 此时 head 指向的人作为新的 tail head = head.next.next // head 指向需要移除的人的下一个人，他作为新的 head tail.next = head // head 的指向改变，重新设定 tail.next 为 head return code} 执行操作 /* 执行操作，m 为设定的初值 */func Run_Jos(ring *Person, m int) { code := m for head != tail { // 当 head 和 tail 不指向同一个人时（ ring 中剩余人数大于 1 ） code = Remove_Jos(ring, code) // 进行移除操作并获取新的密码 } fmt.Print(head.num) // 将 ring 中的最后一个人的序号打印出来} 主函数 func main() { var ring *Person // 添加测试数据 Add_Jos(ring, 1, 3) Add_Jos(ring, 2, 1) Add_Jos(ring, 3, 7) Add_Jos(ring, 4, 2) Add_Jos(ring, 5, 4) Add_Jos(ring, 6, 8) Add_Jos(ring, 7, 4) Run_Jos(ring, 6)} 运行结果 6 1 4 7 2 3 5 总结 单向循环链表与单向链表差别并不大，只是增加了一个尾部指向头部的步骤。这个例子中使用到了 head 和 tail 两个指针用来记录 ring 中的头和尾，这样方便了向其中添加新的数据，而且头尾两个指针也有效减少了在删除过程中循环遍历结点的操作。 多个结构体的实现 定义结构体 package mainimport \"fmt\"type Person struct { num int // 序号 code int // 密码 next *Person // 指向下一个 Person}type Ring struct { head *Person // ring 的头 tail *Person // ring 的尾 count int // ring 中的元素数目} 判断 Ring 是否为空 func (ring *Ring) isEmpty() bool { if ring.head != nil { // 当 head 值为 nil 时 ring 为空 return false } return true} 添加操作 func (ring *Ring) add(code int) { ring.count++ // 放在片段开头是为了方便设定 Person 的 num 属性 if ring.isEmpty() { // ring 为空时首尾相同 ring.tail = &amp;Person{ring.count, code, nil} ring.head = ring.tail } else { oldTail := ring.tail // 暂存 tail ring.tail = &amp;Person{ring.count, code, nil} oldTail.next = ring.tail } ring.tail.next = ring.head // 确保循环性} 移除操作 // 根据密码值移除 Person ，有 num 和 code 两个返回值func (ring *Ring) outFor(code int) (num int, _ int) { if code &lt; 1 { // 值 -1 标志传入参数值非法 return -1, -1 } else if code == 1 { // 当需要移除的是 head code = ring.head.code num = ring.head.num ring.tail.next = ring.head.next ring.head = ring.tail.next } else { // 使用 current 确定移除位置 current := ring.head for i := 0; i &lt; code-2; i++ { current = current.next } // 循环结束后 current 指向需要移除的前一个位置 code = current.next.code num = current.next.num ring.tail = current // current 为新的 tail ring.head = current.next.next // current.next 变成了孤儿，Golang 提供了自动回收机制 ring.tail.next = ring.head // 确保循环性 } ring.count-- return num, code} 执行操作 func (ring *Ring) run(code int) { var num int for ring.head != ring.tail { // 依次打印满足条件时移除元素的 num 值 num, code = ring.outFor(code) fmt.Printf(\"%d \", num) } fmt.Print(ring.head.num) // 打印 ring 中最后一个元素的 num 值} 主函数 func main() { // run 方法的测试 { var ring Ring ring.add(3) ring.add(1) ring.add(7) ring.add(2) ring.add(4) ring.add(8) ring.add(4) ring.run(6) }} 运行结果 6 1 4 7 2 3 5 总结 相比于使用单个结构体实现来说，这种方法避免了独立于结构体之外的 head 和 tail 指针的使用，在程序中减少了指针的操作，主体更容易理解。","link":"/independent-pages/list/data-struct-lessons/josephus-go/index.html"},{"title":"第 2 章 变量和基本类型","text":"指针 空指针使用 nullptr（ C++ 11 中引入） 、NULL ( 预处理变量，cstdlib 中) 、0 生成； 应避免使用 NULL ； 不明确时建议初始化为 nullptr 或 0 。 不能直接操作 void* 指针所指的对象； r 是一个对指针 p 的引用。int *p;int *&amp;r = p; const 限定符const 默认 const 对象仅在文件内有效，如需共享要使用 extern 进行修饰； 非常量引用不能指向一个常量对象（常量引用 -&gt; 对 const 的引用）； ri 绑定了一个 临时量 对象； double dval = 3.14; // const int temp = dval; const int &amp;ri = temp;const int &amp;ri = dval; 当 ri 不是常量，引用绑定到临时量为非法； int &amp;ri = dval; // error 把 * 放在 const 之前用以说明指针是一个常量； int errNumb = 0;int *const curErr = &amp;errNumb; // curErr 将一直指向 errNub 顶层 const 表示指针本身是一个常量，底层 const 表示指针所指的对象是一个常量； 对常量对象取地址是一种底层 const 。 constexpr constexpr 类型只能使用常量表达式进行初始化； constexpr 指针的初值必须是 nullptr 、0 或者是储存于某个固定地址中的对象； 在 constexpr 声明中如果定义了一个指针，限定符只对指针有效。 处理类型别名 使用 别名声明 定义类型别名（ C++ 11 ）； using SI = Sales_item; 一个错误的理解。 typedef char *pstring;const pstring cstr; // 指向 char 的常量指针const char *cstr = 0; // 指向 const char 的指针 auto 使用引用对象的类型； int i = 0, &amp;r = i;auto a = r; // a 是一个整数 忽略顶层 const ，如希望推断出顶层 const 需明确指出。 const auto f = ci; // ci 的推演类型是 int ，f 是 const int decltype （ C++ 11 ）选择并返回操作数的数据类型。 使用的表达式是一个变量，返回该变量的类型（包括顶层 const 和引用）； const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // const intdecltype(cj) y = x; // const int&amp;decltype(cj) z; // 错误，const int&amp; 使用的表达式不是一个变量，返回表达式结果对应的类型； 括号的影响。 int i = 42;decltype((i)) d; // 错误，int&amp;decltype(i) e; // int 自定义数据结构","link":"/independent-pages/list/cpp-primer/2/index.html"},{"title":"顺序表之初用 C 指针","text":"之前没有真正使用 C 语言编写过程序，第一次使用 C 语言进行建立数据结构，因为使用了指针的概念，遇到了很多问题，这里大致说一下。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define INITLENGTH 100#define INCREMENT 10typedef int ElemType; 这是在结构体之上引入的库和定义，其中 ElemType 作为 int 的别名（其实这里不需要，因为顺序表基本都是对数值进行操作）。 在程序中，大致实现了 初始化、输出表元、获取最大值、获取最小值、二分查找、冒泡排序（还没怎么接触到高级排序算法，在看 算法第四版 补充知识）、获得输入、获取索引表元、插入、删除、倒置以及合并操作。 下面来说几个我出错的地方： Insert 方法int Insert(SqList *L, int index, ElemType elem){ if (index &lt; 0 || index &gt; L-&gt;length) return -1; if (L-&gt;length &gt;= L-&gt;size) { ElemType * newbase = (ElemType *) realloc(L-&gt;elem, (L-&gt;size + INCREMENT) * sizeof(ElemType)); if (!newbase) { printf(\"Insert Failed!\"); exit(-2); } else { L-&gt;size = L-&gt;size + INCREMENT; L-&gt;elem = newbase; } } for (int i = L-&gt;length; i &gt; index; i--) { *(L-&gt;elem + i) = *(L-&gt;elem + i - 1); } *(L-&gt;elem + index) = elem; L-&gt;length++; return 0;} 这里的逻辑比较清晰，在表中元素数目大于等于系统分配的内存空间时进行扩容操作，index 不正确会以 -1 的返回值结束调用，我开始将 for 循环移位操作写成了这样： for (int i = L-&gt;length - index; i &gt; 0; i--){ *(L-&gt;elem + i) = *(L-&gt;elem + i - 1);} 这样操作虽然移位元素的数目相同，也就是进行的移位操作次数相同，但是却移动了一些本不该移动的元素。应该是这样： for (int i = L-&gt;length; i &gt; index; i--) Merge 方法SqList Merge(SqList *L1, SqList *L2){ if (L1-&gt;length == 0) return *L2; else if (L2-&gt;length == 0) return *L1; SqList L3; ElemType * base = (ElemType *) calloc(L1-&gt;size + L2-&gt;size, sizeof(ElemType)); L3.elem = base; L3.length = 0; L3.size = L1-&gt;size + L2-&gt;size; int i = 0; int j = 0; int index = 0; while (i &lt; L1-&gt;length) { while (*(L1-&gt;elem + i) == *(L1-&gt;elem + i + 1)) { if (i == L1-&gt;length - 1) { *(L3.elem + index++) = *(L1-&gt;elem + i++); break; } i++; continue; } while (j &lt; L2-&gt;length) { while (*(L2-&gt;elem + j) == *(L2-&gt;elem + j + 1)) { if (j == L2-&gt;length - 1) { *(L3.elem + index++) = *(L2-&gt;elem + j++); break; } j++; continue; } if (*(L1-&gt;elem + i) &lt; *(L2-&gt;elem + j)) { *(L3.elem + index++) = *(L1-&gt;elem + i++); L3.length++; break; } else if (*(L1-&gt;elem + i) &gt; *(L2-&gt;elem + j)) { *(L3.elem + index++) = *(L2-&gt;elem + j++); L3.length++; break; } else { *(L3.elem + index++) = *(L1-&gt;elem + i++); L3.length++; j++; } } } while(i &lt; L1-&gt;length) { if (*(L1-&gt;elem + i) == *(L1-&gt;elem + i + 1)) { if (j == L1-&gt;length - 1) { *(L3.elem + index++) = *(L1-&gt;elem + i++); break; } i++; continue; } *(L3.elem + index++) = *(L1-&gt;elem + i++); L3.length++; } while (j &lt; L2-&gt;length) { if (*(L2-&gt;elem + j) == *(L2-&gt;elem + j + 1)) { if (j == L2-&gt;length - 1) { *(L3.elem + index++) = *(L2-&gt;elem + j++); break; } j++; continue; } *(L3.elem + index++) = *(L2-&gt;elem + j++); L3.length++; } return L3;} 这个方法大致考虑到了所有可能进行操作的 L1 和 L2 的情况，稍稍复杂了一点，具体实现也可以将 L1 与 L2 中的元素复制到 L3 里，再进行排序和查重的操作。 出现了一个很不应该出现的问题，就是类似于这样的 while 语句和 if 语句的条件判断： while (*(L1-&gt;elem + i) == *(L1-&gt;elem + i + 1))if (*(L2-&gt;elem + j) == *(L2-&gt;elem + j + 1)) 在最开始的时候没有进行解引用的操作，😂 写成了这个样子： while (L1-&gt;elem + i == L1-&gt;elem + i + 1)if (L2-&gt;elem + j == L2-&gt;elem + j + 1) 实际上就是对地址进行了比较，就出现了不会执行这部分语句块的问题，所以对 指针 的注意 ⚠️ 尤为重要！！ PS:&emsp;一定要对 * 、 &amp; 和 -&gt; 这三个运算符有一个清晰的认识，具体可以参考 这篇 博客，和 这篇 。 源码下载：SqList.c 这是可以直接运行的程序，在 main 函数中验证了部分方法的正确性。关于结构体的定义这里不会详细做阐释，不懂的知识点请自行补充。","link":"/independent-pages/list/data-struct-lessons/sqlist-c/index.html"},{"title":"algs4-1.2 数据抽象","text":"抽象数据类型 （ADT） 是一种能够对使用者隐藏数据表示的数据类型。使用抽象数据类型时，我们的注意力集中在 API 描述的操作上而不会去关心数据的表示；实现抽象数据类型时，我们的注意力集中在数据本身并将实现对该数据的各种操作。 以适用于各种用途的 API 形式准确地定义问题； 用 API 的实现描述算法和数据结构。 特点：可以在不修改任何用例代码的情况下使用一种算法替换另一种算法并改进所有用例的性能。 1. 使用抽象数据类型抽象数据类型的 API抽象数据类型的定义和静态方法库之间的共同点： 两者的实现均为 Java 类； 实例方法可以接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔； 可能返回指定类型的值。 不同点： API 中会出现名称和类名相同的没有返回值的构造函数； 实例方法不需要 static 关键字，目的是操作数据类型中的值； 尊重 Java 习惯而存在的继承方法，在 API 中显示为灰色。 继承的方法大致有 toString() 、equals() 、compareTo() 、hashCode()。在使用 “+” 运算符将任意数据类型的值和 String 值连接时会调用 toString() 方法。 对象对象的创建与使用调用 new() 时，系统会： 为新的对象分配内存空间； 调用构造函数初始化对象中的值； 返回该对象中的一个引用。 静态方法的主要作用是实现函数；非静态（实例）方法的主要作用是实现数据类型的操作。一个开头是类名，一个开头是对象名。 开发某种给定数据类型的用例： 声明该类型变量，以用来引用对象； 使用关键字 new 触发能够创建该类型的对象的一个构造函数； 使用变量名在语句或表达式中调用实例方法。 使用与对象关联的变量： 赋值语句； 向方法传递对象或是从方法中返回对象； 创建并使用对象的数组。 赋值语句 不会创建对象，而是创建另一个指向某个已经存在的对象的引用。这种情况称为 别名 ：两个变量同时指向同一个对象。 对于原始数据类型的变量，会发生值的复制。而对于引用类型，复制的是引用而非实际的值。例如： int a = 0;int b = a;b++;System.out.println(a);System.out.println(b); 此时输出的 a 的值为 0，b 的值为 1。再试着运行下面的程序： public class Test { public static void main(String[] args) { Num num = new Num(4); Num num2 = num; num2.add(2); System.out.println(num.getValue()); }}class Num { private int value; Num(int value) { this.value = value; } int getValue() { return value; } void add(int increment) { value += increment; }} 这是将对象作为参数的情况。我们可以发现 num.value 的值随着 num2 对 add() 方法的调用改变了。 PS: 方法无法改变原始的引用，但能够改变对象的值。 Java 中的方法只能有一个返回值，如果使用对象的话，实际上就能够返回多个值。 数组与对象Java 中所有非原始数据类型的值都是对象。这样一来，数组也是对象。 创建一个对象数组： 使用方括号语法调用数组的构造函数创建数组； 对于每个数组元素，调用它的构造函数创建相应的对象。 Java 中的对象数组实际上是一个由对象的引用组成的数组。如果对象非常大，在移动对象时只需要移动对象的引用，这样大大提高了效率；而对象非常小的时候，每次获取信息都需要通过引用来操作反而降低了效率。 对象的三大关键性质：状态、标识和行为。 一个数据类型的实现所支持的操作： 创建对象（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的值并返回它的引用。 操作对象中的值（控制对象的行为，可能会改变对象的状态）：使用对象关联的变量调用实例方法来对对象中的值进行操作。 操作多个对象：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身。 2. 抽象数据类型举例几何对象信息处理字符串String a = \"now is \";String b = \"the time \";String c = \"to\"; 方法 返回值 a.length() 7 a.charAt(4) i a.concat(c) “now is to” a.indexOf(&quot;is&quot;) “w i” a.substring(2, 5) “now” a.split(&quot; &quot;)[0] “now” a.split(&quot; &quot;)[1] “is” b.equals(c) false 3. 抽象数据类型的实现 实例变量：每个实例变量的声明都需要一个 可见性修饰符。 构造函数 实例方法 作用域 API、用例与实现 实例变量如果使用 public 修饰的话，根据定义，这种数据类型就不是抽象的了。所以一般不会这么做。 构造函数 类似于静态方法，能够直接访问变量并且没有返回值； 每一个构造函数都会创建一个对象并向调用者返回一个该对象的引用； 名称与类型相同； 支持重载； 如果没有构造函数，将会隐式定义 0，false，null 的默认值（前提是参数没有提供默认值）。 实例方法同静态方法大都是语法上的区别。 作用域 参数变量：整个方法。 局部变量：当前代码段中定义之后的所有语句。 实例变量：整个类。 如果实例变量出现二义性，可以使用 this 进行区别。 4. 更多抽象数据类型的实现维护多个实现 通过前缀描述性修饰符进行区别； 维护一个没有前缀的参考实现以适用大多数用例的需求。 累加器维护一个 int 类型的实例变量来记录已经处理过的数据值的数量，以及一个 double 类型的实例变量来记录所有数据之和，除以数据数量得到平均值。 实现 public class Accumulator { private double total; private int N; public void addDateValue(double val) { N++; total += val; } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestAccumulator { public static void main(String[] args) { // 如果不想使用终端输入命令的方式，此处也可以改为 // int T = StdIn.readInt(); // 如此就可以在输入端输入 T 值 int T = Integer.parseInt(args[0]); Accumulator a = new Accumulator(); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法 % java TestAccumulator 1000Mean (1000 values): 0.51829 可视化的累加器使用 StdDraw 画出所有数据（灰色）和实时平均值（红色）。 实现 public class VisualAccumulator { private double total; private int N; public VisualAccumulator(int trials, double max) { StdDraw.setXscale(0, trials); StdDraw.setYscale(0, max); StdDraw.setPenRadius(.005); } // 副作用：实现绘图 public void addDateValue(double val) { N++; total += val; StdDraw.setPenColor(StdDraw.DARK_GRAY); StdDraw.point(N, val); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(N, total / N); } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestVisualAccumulator { public static void main(String[] args) { int T = Integer.parseInt(args[0]); VisualAccumulator a = new VisualAccumulator(T, 1.0); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法与 Accumulator 用法一致。 5. 数据类型的设计 省略，待更新 补充 原始数据类型更接近计算机硬件所支持的数据类型，使用起来要要快于引用类型。 有时候会用私有实例方法在公有方法之间共享代码。 没有使用 new 关键字创建对象得到的 错误 与引用一个未定义符号相同，构造函数的参数数量不对也会出现相同的错误信息。 创建对象数组每一个对象都需要使用 new 关键字：没有创建数组与为一个未初始化的变量赋值得到的 错误 相同。如果尝试调用未初始化对象的方法，会得到 空指针异常 。 println() 接受一个 Object 对象。 指针是什么？ 实现引用的一种自然方式是使用指针（机器地址），另一种可能是句柄（指针的指针）。前者访问数据的速度很快，后者能够更好地实现垃圾回收。 继承的问题：子类代码可以访问所有实例变量，因此可以改变值。 类中的所有方法都可以访问静态变量。静态变量的作用域是全局的，所以使用时要非常小心。 不再被支持但为了保持兼容性而留在 API 中的方法叫做被弃用（deprecated）的方法。 习题见 习题 1-2","link":"/independent-pages/list/algs4/1/1.2/index.html"},{"title":"algs4-1.4 算法分析","text":"如何更好地将问题规模和运行时间的关系量化？ 计时器的例子 计时器的数据类型 public class Stopwatch { private final long start; /** * 创建一个计时器。 */ public Stopwatch() { start = System.currentTimeMillis(); } /** * 返回创建对象以来经过的时间。 * * @return 从对象创建以来经过的时间（单位：s） */ public double elapsedTime() { long now = System.currentTimeMillis(); return (now - start) / 1000.0; }} 对数组中三个不同元素进行加和检验 public class ThreeSum { /** * 计算数组中相邻三个数的加和，如果等于 0 记录，最后返回计算结果为 0 的次数。 * * @param a 进行处理的数组 * @return 计算结果为 0 的次数 */ public static int count(int[] a) { int n = a.length; int cnt = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) for (int k = j + 1; k &lt; n; k++) if (a[i] + a[j] + a[k] == 0) cnt++; return cnt; }} 测试用例 public static void main(String[] args) { int n = Integer.parseInt(args[0]); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) { a[i] = StdRandom.uniform(-1000000, 1000000); } Stopwatch stopwatch = new Stopwatch(); int cnt = ThreeSum.count(a); System.out.println(cnt+ \" \" + stopwatch.elapsedTime() + \"s\");} 下面这个例子是打印一个图，横坐标为问题规模 N ，纵坐标为处理 N 个随机 6 位整数的运行时间。 public class Test { public static double timeTrial(int N) { int MAX = 1000000; int[] a = new int[N]; for (int i = 0; i &lt; N; i++) a[i] = StdRandom.uniform(-MAX, MAX); Stopwatch timer = new Stopwatch(); int cnt = ThreeSum.count(a); return timer.elapsedTime(); } public static void main(String[] args) { // 坐标轴的范围在这里修改 StdDraw.setXscale(0, 5000); StdDraw.setYscale(-1, 5); StdDraw.setPenRadius(.008); StdDraw.setPenColor(StdDraw.RED); // 这里可以修改 N 的测试范围 for (int N = 1000; N &lt;= 4000; N += 100) { double time = timeTrial(N); System.out.printf(\"%7d %5.1f\\n\", N, time); StdDraw.point(N, time); } }} 我使用这个方法进行了两组操作，分别得到了 N 从 100 到 4000 ，和 N 从 1000 到 4000 的图，它们分别是： 正常来说随着问题规模 N 的增加，运行时间也应该不断增加。但是 N 从 1000 到 4000 的图像却分成了两个部分，我还没有弄明白，你也运行一下试试看吧。 数学模型我们观察 ThreeSum 这个类的实现，它计算了在数组中任意三个不同元素的和： a[1] + a[2] + a[3]a[1] + a[2] + a[4]...a[1] + a[2] + a[N - 1]a[1] + a[3] + a[4]a[1] + a[3] + a[5]...a[2] + a[3] + a[4]...a[N - 3] + a[N - 2] + a[N - 1] 所以相当于遍历了 a[N] 中的所有不同的三个元素，我们可以使用 \\(C_{N}^{3}\\) 来进行计算。算下来 if 语句的执行次数就是： $$\\frac{N(N-1)(N-2)}{6}=\\frac{N^{3}}{6}-\\frac{N^{2}}{2}+\\frac{N}{3}$$ 我们用 ~f(N) 表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。用 g(N)~f(N) 表示 g(N)/f(N) 随着 N 的增大趋近于 1 。 我们就可以使用 ~\\(\\frac{N^{3}}{6}\\) 来表示 ThreeSum 中的 if 语句的执行次数。根据前文所述的所述的数学模型有 \\(T(N)\\)~\\(a{N^{3}}\\) ，其中常数 a 取决于计算机的型号。 成本模型使用成本模型来评估算法的性质，定义了我们所研究算法中的基本操作。比如研究 3-sum 问题，我们记录数组的访问次数。 得到运行时间的数学模型： 确定输入模型，定义问题规模； 识别内循环； 根据内循环中的操作确定成本模型； 对于给定输入，判断这些操作的执行频率。 算法 运行时间的增长数量级 ThreeSum \\(NlogN\\) ThreeSumFast \\(N^{2}logN\\) ThreeSumFast 使用了 Arrays.sort() 的归并排序和 BinarySearch.indexOf() 的二分查找（对整型数组进行处理） ThreeSumFast 源码public class ThreeSumFast { public static int count(int[] a) { Arrays.sort(a); int n = a.length; int cnt = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) if (BinarySearch.indexOf(a, -a[i] - a[j]) &gt; j) cnt++; return cnt; } public static void main(String[] args) { int[] a = StdIn.readInts(); System.out.println(count(a)); }} 显而易见，ThreeSumFast 算法更快。在这里二分查找的增长数量级为线性级别 \\(N\\) ，对数组进行排序时用到的归并排序的增长数量级为线性对数级别 \\(NlogN\\) 。 大致介绍一下常见增长数量级的分类： 常数级别：运行时间不依赖于 \\(N\\) ； 对数级别：仅比常数时间的程序稍慢，典型的例子就是 \\(二分查找\\)； 线性级别：单个 for 循环是最常见的，运行时间和 \\(N\\) 成正比； 线性对数级别：增长数量级为 \\(NlogN\\) ，对数的底数和增长数量级无关，典型的例子是 Merge.sort()（算法 2.4）和 Quick.sort()（算法 2.5）； 平方级别：一般为两个 for 循环，例子有 Selection.sort()（算法 2.1）和 Insertion.sort()（算法 2.2）； 立方级别：一般有三个 for 循环，ThreeSum 就是一个例子； 指数级别：一般描述为 \\(b^{N}\\) ，这里的 b &gt; 1 且为常数。 倍率实验内存 原始数据类型的常见内存、需求 类型 字节 boolean 1 byte 1 char 2 int 4 float 4 long 8 double 8 链表 一个 Node 对象需要使用 40 字节（其中对象开销 16 字节，指向 Item 和 Node 对象的引用各需 8 字节，另外还有 8 字节的额外开销） Integer 对象需要使用 24 字节（16 字节的对象开销，4 字节保存 int 值以及 4 个填充字节） 一个含有 N 的整数的基于链表的栈需要使用（32+64N）字节（16 字节对象开销，引用类型实例变量 8 字节，int 型实例变量 4 字节，4 个填充字节，每个元素包含一个 Node 对象的 40 字节和一个 Integer 对象的 24 字节） 数组一个原始数据类型的数组一般需要 24 字节的头信息（16 字节的对象开销，4 字节用于保存数组长度以及 4 填充字节）。 例如：一个含有 N 个 int 值的数组对象需要使用（24+4N）字节（会被填充为 8 的倍数），如果是 double 则需要使用（24+8N）字节。 字符串对象4 个实例变量（一个 8 字节的指向字符数组的引用和三个 int 值） 3 个 int 值： 字符数组中的偏移量； 计数器（字符串的长度）； 散列值。 所以每个 String 对象会使用 40 字节（16 字节表示对象，三个 4 字节 int 实例变量，8 字节数组引用和 4 个填充字节），这是除字符数组之外字符串所需要的内存空间，字符所需的内存需要另记，因为 String 的 char 数组是在多个字符串之间共享的。（String 对象不可变，多个对象含有同一个 value[] 数组时可以节省内存。 字符串的值和子字符串子字符串重用了 value[] ，只会使用 40 字节的内存。可以说，一个子字符串所需的额外内存是一个常数，构造一个子字符串的时间也是常数。这样做可以避免子字符串复制字符使用线性的时间和空间。 当程序调用一个方法时，系统会从栈中为方法分配所需要的内存用于保存局部变量；方法返回时，它所占用的内存也被返回给了系统栈。 所以在递归程序中创建数组或是其他大型对象是很危险的！ 关注运行成本！ 补充 \\(f(N)\\)~\\(g(N)\\) 的正式定义为 \\(\\lim_{N\\to\\infty}\\frac{f(N)}{g(N)} = 1\\) 习题见 习题 1-4","link":"/independent-pages/list/algs4/1/1.4/index.html"},{"title":"algs4-1.1 基础编程模型","text":"1. 原始数据类型与表达式原始数据类型 &ensp;8 位整数，byte 16 位整数，short 32 位整数，int 64 位整数，long 16 位字符，char 32 位单精度实数，float 64 位双精度实数，double 表达式 Java 中使用 中缀 表达式，即：运算符在字面量或表达式之间。 逻辑运算符中 ! 拥有最高优先级，之后是 &amp;&amp;，然后是 ||。 2. 语句 声明语句：Java 是强类型语言，编译器会检查类型的一致性。 赋值语句：左侧必须是单个变量，右侧是能够得到相应类型的任意表达式。 条件语句：不同操作来处理不同的输入，分为 if 语句和 switch 语句。 循环语句：主要是 while 语句和 for 语句，循环语句中的代码称为循环体。 调用和返回语句：与静态方法有关，是执行流程和代码组织的另一种方式。 其他语句 break 语句：退出循环。 continue 语句：立即开始下一轮循环。 return 语句：返回值。 3. 数组 对于数组 a[]，程序可以通过 a.length() 获取数组长度。 可能出现的异常 ArrayIndexOutOfBoundsException 数组别名当我们将一个数组变量赋给另一个变量，那么两个变量都会指向同一个数组。 int[] a = new int[N];a[i] = 123;int[] b = a;b[i] = 456;System.out.print(a[i]); // 此处输出 a[i] 的值为 456 4. 静态方法静态方法是一组在被调用时会被顺序执行的语句，拥有修饰符 static，区别于实例方法。 方法的性质 方法的参数按值传递：方法中使用的参数变量可以引用调用者的数组并改变其内容，但不能改变与原数组变量本身（值传递）。也就是在方法中改变一个参数变量的值对调用者本身没有影响。 方法名可以被重载：例如同名方法可以传入多种参数类型。 方法只能返回一个值，但可以包含多个返回语句：返回被执行语句中第一条返回语句的参数。 方法可以产生副作用：void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或改变系统状态）。 递归方法可以调用自己；递归代码比相应的非递归代码更加简洁优雅、易懂。 最简单的情况：方法的第一条语句总是一个包含 return 的条件语句。 递归的调用总是去尝试解决规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。 // 二分查找的递归实现public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1);}public static int rank(int key, int[] a, int lo, int hi) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; }} 基础编程模型Java 开发的基本模是编写一个静态方法库（包含一个 main() 方法）来完成一个任务。 模块化编程我们可以构造许多个静态方法库（模块），一个库中的静态方法也可以调用另一个库中定义的静态方法。这能够带来很多好处： 程序整体的代码量很大时，每次处理的模块大小仍然适中； 可以共享和重用代码而无需重新实现； 很容易用改进的实现替换旧的实现； 可以为解决编程问题建立合适的抽象模型； 缩小测试范围。 单元测试每一个静态方法库中都包含一个 main() 函数来测试库中的所有方法（有些编程语言不支持多个 main() 方法，所以不支持这种方式）。我们可以将 main() 方法作为一个开发用例，在开发过程中用它来测试更多的细节；也可以将它编写成一个测试用例来对所有代码进行一个全面的测试。当用例越来越复杂，我们可能会将它独立成一个模块。 外部库 系统标准库 java.lang.*：包括实现了常用数学函数的 Math 库以及其他。 导入的系统库，例如 java.util.Arrays：需要在程序的开头使用 import 语句导入。 5. API模块化编程的一个重要组成部分就是记录库方法的用法并提供其他人参考的文档；我们应该将自己编写的每一个程序都当作一个日后可以重用的库。关于 API 的说明可参考 什么是 API ？ 6. 输入输出重定向与管道重定向将程序的输出重定向至一个文件： % java RandomSeq 1000 100.0 200.0 &gt; data.txt 重定向标准输入使从文件中读取数据： % java Average &lt; data.txt 管道将一个程序的输出重定向为另一个程序的输入叫做管道： % java RandomSeq 1000 100.0 200.0 | java Average 突破了能够处理的输入输出流的限制 运行的先后顺序由操作系统决定 7. 白名单过滤信用卡公司的例子： 将客户账号保存在一个文件中，称为白名单； 从标准输入中得到每笔交易的账号； 使用测试用例在标准输出中打印所有与客户无关的账号，公司很可能拒绝此类交易。 % java BinarySearch tinyW.txt &lt; tinyT.txt 此处的 tinyW.txt 就是一个白名单。 补充 Java 中一个静态方法不能作为另一个静态方法的参数，但在一些其他语言中可以。 习题见 习题 1-1","link":"/independent-pages/list/algs4/1/1.1/index.html"},{"title":"algs4 习题 1-4","text":"练习1. 证明不同组合数的个数我们可以使用中学排列与组合的知识： \\(Res = C_N^3 = \\frac{A_N^3}{3!} = \\frac{N!}{(N-3)!3!} = \\frac{N(N-1)(N-2)}{6}\\) 2. 修改 ThreeSum 以处理两值相加超出 int 范围public static int count(int[] a) { int n = a.length; int cnt = 0; long num_1; long num_2; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) for (int k = j + 1; k &lt; n; k++) if (a[i] + a[j] + a[k] == 0) { num_1 = a[i]; num_2 = a[j]; if (num_1 + num_2 &gt; Integer.MAX_VALUE) continue; if (a[i] + a[j] == -a[k]) cnt++; } return cnt;} 我在这里用了两个 long 类型来保存三个数中前两个数的值，当它们相加超过 Integer.MAX_VALUE 时，continue… 3. 修改 DoublingTest修改 main 函数： public static void main(String[] args) { StdDraw.setXscale(0, 20000); StdDraw.setYscale(-50, 200); StdDraw.setPenRadius(0.01); for (int n = 250; true; n += n) { double time = timeTrial(n); StdOut.printf(\"%7d %7.1f\\n\", n, time); StdDraw.point(n, time); }} 生成的图像类似于这样： 4. 为 TwoSum 建立表格这个 TwoSum 大致是这样的，我们标出语句块： public class TwoSum { public static int count(int[] a) { int N = a.length; // &lt;A&gt; int cnt = 0; for (int i = 0; i &lt; N; i++) // &lt;B&gt; for (int j = i + 1; j &lt; N; j++) // &lt;C&gt; if (a[i] == -a[j]) // &lt;D&gt; cnt++; // &lt;/B&gt; &lt;/C&gt; &lt;/D&gt; return cnt; // &lt;/A&gt; }} 语句块 运行时间（以秒记） 频&emsp;率 总 时 间 D \\(t_0\\) \\(x\\)（取决于输入） \\(t_0 {x}\\) C \\(t_1\\) \\(\\frac{N^2}{2} - \\frac{N}{2}\\) \\(t_1 (\\frac{N^2}{2} - \\frac{N}{2})\\) B \\(t_2\\) \\(N\\) \\(t_2 {N}\\) A \\(t_3\\) \\(1\\) \\(t_3\\) \\(总时间\\) \\(\\frac{t_1}{2} N^2 + (t_2 - \\frac{t_1}{2}) N + t_3 + t_0 x\\) \\(近似\\) ~\\(\\frac{t_1}{2} N^2\\)（假设 \\(x\\) 很小） \\(增长的数量级\\) \\(N^2\\) 5. 量的近似&emsp;a. ~\\(N\\) &emsp;b. ~\\(\\frac{1}{N}\\) &emsp;c. ~\\(\\frac{1}{2}\\) &emsp;d. ~\\(N^3\\) &emsp;e. ~\\(lgN\\) &emsp;f. ~\\(lgN^2\\) &emsp;g. ~\\(0\\) 6. 给出代码的增长数量级&emsp;a. \\(\\frac{1\\times(1-2^{log_2{N}+1-1})}{1-2}\\) = \\(2N-1\\) ~ \\(2N\\) —&gt; 增长数量级为 N &emsp;b. \\(\\frac{1\\times(1-2^{log_2{N}+1-1})}{1-2}\\) = \\(2N-1\\) ~ \\(2N\\) —&gt; 增长数量级为 N &emsp;c. \\(Nlog_2{N}\\) —&gt; 增长数量级为 NlgN &emsp;注： 如果 a b 使用等比数列近似计算的话看上面，另有方法详解见 StackExchange 。 7. 成本模型这里的话我们要理解成本模型是我们用来评估算法性质的一个标准。 所以如果统计算术操作为成本模型的话，在第 3 个 for 循环的 if 语句中进行了两次加和操作和一次比较操作，这样的话和数组访问次数相同，也是 ~\\(\\frac{N^3}{2}\\) 次。 证明： 每次循环执行 3 次操作。 8. 整数对的数量我们可以模仿 TwoSumFast 的做法，它的增长数量级一样也为 \\(NlogN\\) 。 public static void main(String[] args) { int[] a = StdIn.readAllInts(); int cnt = 0; Arrays.sort(a); for (int i = 0; i &lt; a.length; i++) { if (BinarySearch.indexOf(a, a[i]) &gt; i) cnt++; } System.out.println(cnt);} 9. 给出公式\\(T(N_0) = 2^b\\cdot{T}\\) \\(T(2N_0) = (2^b)^2\\cdot{T}\\) \\(…\\) \\(T(N) = (2^b)^{lg\\frac{N}{N_0}}\\cdot{T}\\) \\(T(N) = (\\frac{N}{N_0})^b\\cdot{T}\\) 说明： 这里的 \\(lg\\) 也就是 \\(log_2\\) 。 10. 修改 BinarySearchpublic static int indexOf(int[] a, int key) { int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) hi = mid - 1; else if (key &gt; a[mid]) lo = mid + 1; else for (int i = mid; true; i--) if (a[i] != a[mid]) return i + 1; } return -1;} 这种方法修改的话不能保证数组中有大量待查找元素时的线性对数级别运算，也就是在我要查找的数组中有 N 个与 key 同值的元素。我们也可以尝试用下面这种方法： public static int indexOf(int[] a, int key) { int lo = 0; int hi = a.length - 1; while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) hi = mid - 1; else if (key &gt; a[mid]) lo = mid + 1; else { if (mid &gt; 0 &amp;&amp; a[mid - 1] == key) hi = --mid; else return mid; } } return -1;} 11. 方法 howManypublic static int howMany(int[] a, int key) { int lo = 0; int hi = a.length - 1; int min = BinarySearch.indexOf(a, key); while (lo &lt;= hi) { int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) hi = mid - 1; else if (key &gt; a[mid]) lo = mid + 1; else { if (mid &gt; 0 &amp;&amp; a[mid + 1] == key) lo = ++mid; else return mid + 1 - min; } } return -1;} 我们这里用到了 BinarySearch 中的 indexOf 方法，但要注意这里 indexOf 是我们改进之后的方法，返回值是数组中的最小索引。我们在 while 中获得了最大索引 mid ，所以元素数量就为 mid + 1 - min 这个值。不用多说，自己试试吧! 12. 打印公共元素public static void sameElements(int[] a, int[] b) { for (int i = 0, j = 0; i &lt; a.length &amp;&amp; j &lt; b.length; ) { if (a[i] &lt; b[j]) i++; else if (a[i] &gt; b[j]) j++; else { if (i == 0 || a[i] != a[i - 1]) System.out.printf(\"%d \", a[i]); i++; j++; } }} 上面的例子考虑到了多种可能发生的情况，且打印出的元素不会重复。 13. 内存量&emsp;a. Accumulator 中有 16 字节的对象开销，8 字节保存 double 值，4 字节保存 int 值以及 4 个填充字节，共 32 字节； &emsp;b. Transaction 中有 16 字节的对象开销，40 字节用来保存 String 对象，8 字节保存 double 值，以及保存 Date 对象的 32 字节，共 96 字节； &emsp;c. FixedCapacityStackOfStrings 中有 16 字节的对象开销，4 字节用来保存 int 值，\\(\\displaystyle\\sum_{i=0}^N{(40+(24+2n))}\\) 个字节用来保存字符串数组（n 表示每个字符串所含字符的个数），以及 4 个填充字节，共 \\((\\displaystyle\\sum_{i=0}^N{(40+(24+2n))} + 24)\\) 个字节； &emsp;‼️ 下面的四个都不确定，待修正… &emsp;d. Point2D 中有 16 字节的对象开销，两个 8 字节的 double 值，共 32 个字节； &emsp;e. Interval1D 中有 16 字节的对象开销，两个 8 字节的 double 值，共 32 个字节； &emsp;f. Interval2D 中有 16 字节的对象开销，两个 32 字节的 Interval1D 对象，共 80 字节； &emsp;g. Double 中有 16 字节的对象开销，六个 8 字节的 double 值，四个 4 字节的 int 值，共 80 字节。","link":"/independent-pages/src/algs4/1/1.4/index.html"},{"title":"algs4 习题 1-1","text":"知乎上有一篇总结的还不错, 如果觉得不够详细，或者想要参考题目以及其他答案的同学，可以在 这里 找到。 练习1. 表达式的值&emsp;a. 7&emsp;b. 200.0000002&emsp;c. true 2. 类型和值&emsp;a. double, 1.618&emsp;b. double, 10.0&emsp;c. boolean, true&emsp;d. String, 33 3. equal 判断import java.util.Scanner;public class Test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); if (a == b &amp;&amp; b == c) { System.out.println(\"equal\"); } else { System.out.println(\"not equal\"); } }} 4. 语句修正if (a &gt; b) c = 0; else b = 0; 5. 范围判断import java.util.Scanner;public class Test { public static boolean right(double d) { if (d &gt;= 0.0 &amp;&amp; d &lt;= 1.0) { return true; } else { return false; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); double x = sc.nextDouble(); double y = sc.nextDouble(); if (right(x) &amp;&amp; right(y)) { System.out.println(\"true\"); } else { System.out.println(\"false\"); } }} 6. Fibnonacci 数列// 斐波那契数列的非递归算法int f = 0;int g = 1;for (int i = 0; i &lt;= 15; i++) { System.out.println(f); f = f + g; g = f - g;} 结果01123581321345589144233377610 7. 打印的值&emsp;a. 3.00009&emsp;b. 499500&emsp;c. 10000 8. 打印结果&emsp;a. b&emsp;b. 197&emsp;c. e 9. 正整数二进制 Java 中有内置方法 Integer.toBinaryString(); // 一个简洁的实现方法String s = \"\";for (int n = N; n &gt; 0; n /= 2) { s = (n % 2) + s;} 10. 代码存在的问题没有用 new 为 a[] 分配内存，会产生一个 variable a might not have been initialized 的编译错误。 int[] a;for (int i = 0; i &lt; 10; i++) { a[i] = i * i;} 11. 打印二维布尔数组// 已初始化 boolean 类型二维数组 bfor (boolean[] booleans : b) { System.out.print(lineNumber++ + \"| \"); for (boolean aBoolean : booleans) { if (aBoolean) { System.out.print(\"*\"); } else { System.out.print(\" \"); } } System.out.println();} 12. 打印结果此处书中有误，代码段应为： int[] a = new int[10];for (int i = 0; i &lt; 10; i++) a[i] = 9 - i;for (int i = 0; i &lt; 10; i++) a[i] = a[a[i]];for (int i = 0; i &lt; 10; i++) System.out.println(i); 结果0123443210 13. 二维数组的转置// 使用 int 类型数组举例，已初始化数组 a[M][N]int[][] temp = new int[N][M];for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][j] = a[j][i]; System.out.print(temp[i][j] + \" \"); } System.out.println();} 14. 返回不大于 log₂N 的最大整数public static int lg(int N) { int result = 0; int temp = 2; while (temp &lt; N) { temp *= 2; result++; } return result;} 15. 返回长度为 M 的数组public static int[] histogram(int[] a, int M) { int[] temp = new int[M]; for (int i = 0; i &lt; M; i++) { for (int value : a) { if (i == value) temp[i]++; } } return temp;} 16. exR1(6) 的返回值311361142246 17. 递归函数的问题这段代码中的基础情况永远不会被访问。调用 exR2(3) 会产生调用 exR2(0)、exR2(-3) 和 exR2(-6)，循环往复直到发生 StackOverflowError。 18. 考察乘法与乘方的递归实现 修改前： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a + a, b / 2); return mystery(a + a, b / 2) + a;} 返回值 mystery(2, 25) = 50mystery(3, 11) = 33mystery(a, b) = a * b 核心思想： x * y = (x * 2 * 2 * ...) * (y / 2 / 2 / ...)PS: 此处的 x 可能为偶数，但 y 必为奇数。 修改后： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a * a, b / 2); return mystery(a * a, b / 2) * a;} 返回值 mystery(2, 25) = 33554432mystery(3, 11) = 177147mystery(a, b) = aᵇ 核心思想： x ^ y = (x ^ 2) ^ (y / 2) 19. 改进 F(N) 的实现书上的递归方法探究一小时之内能够得到 F(N) 结果最大的 N 值因为耗时比较长这里就不做尝试了。改进的方法可以参考 6 中的 斐波那契数列的非递归算法 ，下面的是按书上要求利用数组保存值的改进方法： public static long F(int N) { int[] a = new int[N]; a[0] = 0; a[1] = 1; for (int i = 2; i &lt; N; i++) { a[i] = a[i - 1] + a[i - 2]; } return a[N - 1];} 20. ln(N!) 的递归求解public static double ln(int N) { if (N == 0 || N == 1) { return; } else { return ln(N - 1) + Math.log(N); }} 21. 输入数据打印表格这里用到了 printf() 的格式化输出，不懂的同学请自行参考 菜鸟教程 。 System.out.print(\"Please input data count: \");Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();String[] nameArray = new String[n];int[] integerArray1 = new int[n];int[] integerArray2 = new int[n];for (int i = 0; i &lt; n; i++) { nameArray[i] = scanner.next(); integerArray1[i] = scanner.nextInt(); integerArray2[i] = scanner.nextInt();}System.out.println(\"|----------|-----|-----|-----|\");for (int i = 0; i &lt; n; i++) { System.out.printf(\"|%-10s|%-5d|%-5d|%.3f|\\n\", nameArray[i], integerArray1[i], integerArray2[i], ((double) integerArray1[i] / integerArray2[i])); System.out.println(\"|----------|-----|-----|-----|\");} 看到有一个比较有意思的解题方法，思路是用 split() 方法将得到的两行数据进行拆分。缺点是如果输入的数据不是以单个空格为间隔就会报 NumberFormatException 的异常。 Scanner sc = new Scanner(System.in);String[] a = new String[2];int index = 0;while (index &lt; a.length) { a[index] = sc.nextLine(); index++;}for (String s : a) { String[] stringArr = s.split(\" \"); int num1 = Integer.parseInt(stringArr[1]); int num2 = Integer.parseInt(stringArr[2]); System.out.printf(\"%-10s%-5d%-5d%.3f\\n\", stringArr[0], num1, num2, ((double) num1 / num2));} 22. BinarySearch-按递归深度缩进如果你忘记了之前的 rank() 方法，可以在 这里 找到它。下面来对它进行改写： public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1, 1);}// 如果是在某一限定范围内进行查找，则需要手动传入参数 `deep` 的值// `deep` 的值需要设定在大于等于 1 的整数群中，否则在第 3 - deep 行中才会出现缩进效果public static int rank(int key, int[] a, int lo, int hi, int deep) { // 实现缩进 for (int i = 1; i &lt; deep; i++) { System.out.print(\" \"); } System.out.printf(\"%d. lo: %d hi: %d\\n\", deep, lo, hi); // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1, deep + 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi, deep + 1); } else { return mid; }} 23. BinarySearch 的测试用例public static void main(String[] args) { int[] whiteList = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.print(\"Please input \\\"+\\\" or \\\"-\\\": \"); // 为避免读入多余字符使用了 edu.princeton.cs.algs4 包中 StdIn 类里的 readChar() 方法 char flag = StdIn.readChar(); // 读入第一个字符以外的其余字符（不作用途） StdIn.readLine(); System.out.print(\"Please input keys(Split with space): \"); String[] keyList = StdIn.readLine().split(\" \"); for (String s : keyList) { if (flag == '+') { if (rank(Integer.parseInt(s), whiteList) == -1) { System.out.printf(\"%s \", s); } } else if (flag == '-') { if (rank(Integer.parseInt(s), whiteList) != -1) { System.out.printf(\"%s \", s); } } } System.out.println(\"\\nDone!\");} 24. 欧几里得算法计算最大公约数public class Euclid { public static int euclid(int p, int q) { if (q == 0) { return p; } System.out.printf(\"p = %d, q = %d\\n\", p, q); // 交换值的目的是为了减小递归的运算次数 if (p &lt; q) { int temp = p; p = q; q = temp; } return euclid(q, p % q); } public static void main(String[] args) { int p = StdIn.readInt(); int q = StdIn.readInt(); System.out.println(\"\\nresult = \" + euclid(p, q)); }} 25. 数学归纳法证明欧几里得算法参考：&emsp;简书 - 欧几里得算法心得(辗转相除法)&emsp;百度文库 - 辗转相除法的证明 提高题26. 三个数字排序第一行：a &gt; b第二行：a &gt; c第三行：b &gt; c 得到：a ≧ b ≧ c 27. 二项分布","link":"/independent-pages/src/algs4/1/1.1/index.html"},{"title":"algs4-1.3 背包、队列和栈","text":"三种数据类型：背包（Bag）、队列（Queue）和栈（Stack）。它们的不同之处就在于删除或者访问对象的顺序不同。 1. API 表 1.3.1&emsp;泛型可迭代的基础集合数据类型的 API 背包 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; Bag() 创建一个空背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 先进先出（FIFO）队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 下压（后进先出，LIFO）栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; Stack() 创建一个空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中的元素数量 泛型泛型也叫参数化类型。看个例子： Stack&lt;String&gt; stack = new Stack&lt;String&gt;();Queue&lt;Date&gt; queue = new Queue&lt;Date&gt;(); 如果向 stack 中添加 Date 对象（或是任何非 String 类型数据），或者是向 queue 中添加 String 对象（或是任何非 Date 类型数据），都会得到一个编译时的错误。 自动装箱类型参数必须被实例化为引用类型，在处理赋值语句、方法的参数和算术或逻辑表达式时，Java 会自动在引用类型和对应的原始数据类型之间进行转换。例如： Stack&lt;Integer&gt; stack = enw Stack&lt;Integer&gt;();stack.push(17); // 自动装箱 (int -&gt; Integer)int i = stack.pop(); // 自动拆箱 (Integer -&gt; int) 可迭代的集合类型直接上例子： // 假设在 Queue 中维护一个交易集合Queue&lt;Transaction&gt; queue = new Queue&lt;Transaction&gt;();// 如果集合是可迭代的，打印交易列表for (Transaction t : queue) { StdOut.println(t);} 背包背包不支持从中删除元素，迭代的顺序不确定且与用例无关。使用 Bag 就说明元素的处理顺序不重要，典型用例就是计算平均值和标准差: public class Stats { public static void main(String[] args) { Bag&lt;Double&gt; numbers = new Bag&lt;&gt;(); while (!StdIn.isEmpty()) numbers.add(StdIn.readDouble()); int N = numbers.size(); double sum = 0.0; for (double x : numbers) sum += x; double mean = sum / N; sum = 0.0; for (double x : numbers) sum += (x - mean) * (x - mean); double std = Math.sqrt(sum / (N - 1)); StdOut.printf(\"Mean: %.2f\\n\", mean); StdOut.printf(\"Std dev: %.2f\\n\", std); }} 先进先出（FIFIO）队列使用 foreach 语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。在应用程序中使用队列的主要原因就是它在保存元素的同时也保存了顺序，也就保证了入列和出列顺序相同。 队列的用例public static int[] readInts(String name) { // 在这里 in 对象的作用就是来保存传入的整型数组的元素作为 System.in 输入 In in = new In(name); Queue&lt;Integer&gt; q = new Queue&lt;&gt;(); while (!in.isEmpty()) q.enqueue(in.readInt()); int N = q.size(); int[] a = new int[N]; for (int i = 0; i &lt; N; i++) a[i] = q.dequeue(); return a;} 下压栈下压栈是一种基于后进先出（LIFO）策略的集合类型，叠书就是一个栈的例子。浏览网页时会遇到栈的另一个例子：单击“回退”按钮可以重新访问之前的页面。栈另一个特点就是将存入的数据逆序排列，下面的代码就是一个典型的例子： public class Reverse { public static void main(String[] args) { Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); while (!StdIn.isEmpty()) s.push(StdIn.readInt()); for (int i : s) StdOut.println(i); }} 算术表达式求值E.W.Dijkstra 发明了一个非常简单的算法，用到了两个栈（操作数栈、运算符栈）。具体思路： 将操作数压入（push）操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。 在处理完最后一个括号后，操作数栈上就只剩一个表达式的值。运算顺序： (1 + ((2 + 3) * (4 * 5)))(1 + (5 * (4 * 5)))(1 + (5 * 20))(1 + 100)101 Dijkstra 的双栈算术表达式求值算法public class Evaluate { public static void main(String[] args) { Stack&lt;String&gt; ops = new Stack&lt;&gt;(); // 运算符栈 Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); // 操作数栈 while (!StdIn.isEmpty()) { // readString() 方法使用了 Scanner.next() 来读取字符串 String s = StdIn.readString(); if (s.equals(\"(\")); else if (s.equals(\"+\")) ops.push(s); else if (s.equals(\"-\")) ops.push(s); else if (s.equals(\"*\")) ops.push(s); else if (s.equals(\"/\")) ops.push(s); else if (s.equals(\"sqrt\")) ops.push(s); else if (s.equals(\")\")) { String op = ops.pop(); double val = vals.pop(); if (op.equals(\"+\")) val = vals.pop() + val; else if (op.equals(\"-\")) val = vals.pop() - val; else if (op.equals(\"*\")) val = vals.pop() * val; else if (op.equals(\"/\")) val = vals.pop() / val; else if (op.equals(\"sqrt\")) val = Math.sqrt(val); vals.push(val); } else vals.push(Double.parseDouble(s)); } StdOut.println(vals.pop()); }} 没有弄清楚这个用例很容易就会出现异常，或是计算出错误的结果。这是一个简单的算法的实现，它有几点要求： 输入的每个字符串都以空格隔开； 必须要有右括号（否则不能实现计算）； 每次只能进行两个操作数的运算； 开平方也是要需要加括号的。 所以为了保险起见，还是要清晰一点。来个稍复杂一些的，比如要计算 12/(6-sqrt(2*8))，我们就这样写： ( 12 / ( 6 - ( sqrt ( 2 * 8 ) ) ) ) 用过 Emacs 学习了 emacs-lisp 或者学过 lisp 语言的同学可能会想，如果用 lisp 语法进行输入可不可以得到正确结果呢 🧐？同样计算上面式子，输入下面的内容，自己试一试：( / 12 ( - 6 ( sqrt ( * 2 8 ) ) ) ) 另外，如果使用 IDE 工具，想要结束输入需要按组合键 Ctrl + D（Windows）或 Command + D（Mac）。 2. 集合类数据类型的实现定容栈 表 1.3.2&emsp;一种表示定容字符串栈的抽象数据类型 API public class FixedCapacityStackOfStrings FixedCapacityStackOfStrings(int cap) 创建一个容量为 cap 的空栈 void push(String item) 添加一个字符串 String pop() 删除最近添加的字符串 boolean isEmpty() 栈是否为空 int size() 栈中的字符串数量 上面这个数据类型与栈的区别就在于它只能处理 String 值，要求用例指定一个容量且不支持迭代。 它的实例变量为一个用于保存栈中元素的数组 a[] ，和一个用于保存栈中元素数量的整数 N 。 添加和删除元素时 N 的值都会发生变化。 数据类型的实现public class FixedCapacityStackOfStrings { private String[] a; // 存储栈中元素的数组 private int N; // 记录数组大小 public FixedCapacityStackOfStrings(int cap) { a = new String[cap]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(String item) { a[N++] = item; } // 缩减数组大小，丢弃最后一个元素 public String pop() { return a[--N]; }} 理解了上面的实现，请务必完全理解下面的内容： 测试用例public static void main(String[] args) { FixedCapacityStackOfStrings s = new FixedCapacityStackOfStrings(100); while (!StdIn.isEmpty()) { String item = StdIn.readString(); if (!item.equals(\"-\")) s.push(item); else if (!s.isEmpty()) StdOut.print(s.pop() + \" \"); } StdOut.println(\"(\" + s.size() + \" left on stack)\");} 输入数据 to be or not to - be - - that - - - is 会得到结果 to be not that or be 那么符号 “-” 的作用究竟是什么呢？请仔细思考。 泛型上面的例子可以使用泛型进行处理，这样做是有好处的，使用泛型就可以处理不仅仅是 String 类型的数据。 public class FixedCapacityStack&lt;Item&gt; {...} Item 是一个类型参数，可以理解为象征性的占位符。前面也有提到过泛型，这里需要记住的一点就是：Java 会使用类型参数 Item 来检查类型不匹配的错误。 如果我们想要创建一个泛型的数组，会想要这样写： Item[] a = new Item[cap]; 但其实这样做是不行的。由于某些历史和技术原因，Java 中并不允许创建泛型数组，感兴趣的同学可以： 参考知乎上的 回答 ； 阅读掘金上的文章 泛型的基本原理 ； 自行搜索（Google、百度、多吉搜索、秘迹搜）。 我们可以使用类型转换来解决这个问题： Item[] a = (Item[]) new Object[cap]; 这段代码能够达到我们需要的效果，但 Java 编译器会给出一条类似于这样的警告：Unchecked cast: 'java.lang.Object[]' to 'Item[]' ，不过可以忽略它。 表 1.3.4&emsp;一种表示泛型定容栈的抽象数据类型 API public class FixedCapacityStack FixedCapacityStack(int cap) 创建一个容量为 cap 的空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中的元素数量 使用泛型来实现数据类型后，代码也改变了： 数据类型的实现 public class FixedCapacityStack&lt;Item&gt; { private Item[] a; private int N; public FixedCapacityStack(int cap) { a = (Item[]) new Object[cap]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(Item item) { a[N++] = item; } public Item pop() { // 如果要避免数据游离，就参考下面的 pop() 实现 return a[--N]; }} 测试用例 public static void main(String[] args) { FixedCapacityStack&lt;String&gt; s = new FixedCapacityStack&lt;&gt;(100); while (!StdIn.isEmpty()) { String item = StdIn.readString(); if (!item.equals(\"-\")) s.push(item); else if (!s.isEmpty()) StdOut.print(s.pop() + \" \"); } StdOut.println(\"(\" + s.size() + \" left on stack)\");} 调整数组的大小在 Java 中，数组一旦创建，就不可以改变它的大小，栈使用的空间只能是这个最大容量的一部分。正常来说应该有一个 isFull() 的方法来判断栈是否已满，避免数据溢出。先不实现这个方法，我们通过修改数组的实现来动态调用数组的大小以保证数据存储的最大利用率。 实现一个将栈移动到另一个大小为 max 的数组中的方法：// 这里不允许使用其他类调用这个方法，所以使用了 private 修饰符private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[i]; } a = temp;} 这个方法所起到的间接作用就是扩大了数组 a[] 的大小。 修改 push() 方法，在数据量达到数组最大容量时，将数组的容量扩大到 2 倍。 public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item;} 修改 pop() 方法，在数据量不及总容量的 1/4 时，缩减数组容量到 1/2： public Item pop() { Item item = a[--N]; // 避免对象游离（见下节） a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item;} 这里将最小数据量控制在 1/4 ，栈永远不会溢出，使用率不会低于 1/4（除了栈为空的情况）。 PS: 这里请自行理解。 对象游离在上面使用 pop() 方法弹出了一个元素，它就不会再被访问了，但数组中的引用仍可以让它继续存在。像这种保存一个不需要的对象的引用的情况就称之为游离。 为了避免游离，我们只需要将弹出的元素值设置为 null，这会覆盖无用的引用，并使系统在该元素使用完毕后回收它的内存。 迭代我们知道 foreach 语句可以迭代访问集合中的数据，其实它本质上与 while 语句是等价的，看这两组代码： Stack&lt;String&gt; collection = new Stack&lt;&gt;();for (String s : collection) StdOut.println(s); Stack&lt;String&gt; collection = new Stack&lt;&gt;();Iterator&lt;String&gt; i = collection.iterator();while (i.hasNext()) { String s = i.next(); StdOut.println(s);} 可迭代的集合的集合数据类型需要： 实现一个 iterator() 方法并返回一个 Iterator 对象； Iterator 类必须包含两个方法：hasNext()（返回一个 boolean 值）和 next()（返回一个集合中的泛型元素）。 对与可迭代的数据类型，Java 中定义了所需接口 java.lang.Iterable ： public interface Iterable&lt;Item&gt; { Iterator&lt;Item&gt; iterator();} 我们使用接口机制来指定一个类所必须实现的方法，所以在一个需要迭代的集合中我们必须实现接口中的 iterator() 方法。 要逆序迭代遍历整个数组，我们定义一个名为 ReverseArrayIterator 的迭代器的类来实现 Iterator 接口（意味着需要实现 Iterator 接口中的方法），作为实现了 Iterable 接口的集合中 iterator() 方法的返回值。 接口 Iterator public interface Iterator&lt;Item&gt; { boolean hasNext(); Item next(); void remove();} 迭代器 ReverseArrayIterator private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { return i &gt; 0; } @Override public Item next() { if (i == 0) throw new NoSuchElementException(); return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); }} 我们这里没有给出 remove() 方法的实现，因为我们希望避免在迭代中穿插能够修改数据结构的操作。这个类是实现在栈类的一个嵌套类中（栈类可以是上面提到的类 FixedCapacityStack ），我们来重写一下这个栈类： import java.util.Iterator;import java.util.NoSuchElementException;public class FixedCapacityStack&lt;Item&gt; implements Iterable { private Item[] a; private int N; public FixedCapacityStack(int cap) { a = (Item[]) new Object[cap]; } private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) temp[i] = a[i]; a = temp; } @Override public Iterator&lt;Item&gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { return i &gt; 0; } @Override public Item next() { if (i == 0) throw new NoSuchElementException(); return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); } } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item; } public Item pop() { Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; }} 如果不想让 ReverseArrayIterator 作为这个栈类的嵌套类，你也可以单独新建一个类来实现这个迭代器。但要注意的是，ReverseArrayIterator 实现了 Iterator 接口的同时实现了 next() 方法，这个方法拥有一个泛型的返回值。所以我们要这样去定义这个类： public class ReverseArrayIterator&lt;Item&gt; implements Iterator&lt;Item&gt; {...} 其实在你在试过之后就会发现这样是不行的，因为在这个迭代器中使用到了栈类中的数据（存储栈中元素的数组和这个数组所存元素个数）。所以还是就让它做栈类的嵌套类吧！ 另外要注意的就是 Iterable 在 java.lang 中，而 Iterator 在 java.util 中（因为某些历史原因）。 算法 1.1 是 Stack API 的一种能够动态改变数组大小的实现， 它几乎达到了任意集合类数据类型的实现的最佳性能： 每项操作的用时都与集合大小无关； 空间需求总是不超过集合大小乘以一个常数。 缺点在于某些 push() 和 pop() 操作会调整数组的大小：这项操作的耗时和栈大小成正比。我们会学习克服该缺陷的办法，使用一种不同的方式来组织数据。 算法 1.1&emsp;下压（LIFO）栈（能够动态调整数组大小的实现） import java.util.Iterator;import java.util.NoSuchElementException;public class ResizingArrayStack&lt;Item&gt; implements Iterable { private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() { return N == 0; } public int size() { return N; } private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[i]; } a = temp; } public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item; } public Item pop() { Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; } @Override public Iterator&lt;Item&gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { if (i == 0) throw new NoSuchElementException(); return i &gt; 0; } @Override public Item next() { return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); } }} PS: 好像跟我们之前写的那个没有什么不同 😅 3. 链表链表是一种递归的数据结构，他或者为空（null），或者指向一个结点（node）的引用，该结点含有一个泛型的与与元素和一个指向另一条链表的引用。 结点记录我们可以在嵌套类中定义结点的抽象数据类型。 private class Node { Item item; Node next;} 我们会通过 new Node() 触发无参的构造方法来创建一个 Node 类型的对象，它会是一个实例化变量初始为 null 的指向某个 Node 对象的引用。这种类型的类有时也被称为记录。 构造链表我们尝试构造一个含有元素 to、be 和 or 的链表，先为每个元素创造结点： Node first = new Node();Node second = new Node();Node third = new Node(); 我们在 item 域中存放 String 类型的数据： first.item = \"to\";second.item = \"be\";third.item = \"or\"; 再设置 next 域来构造链表： first.next = second;second.next = third; 这里 third.next 还是 null 的值，也就是说 third 指向的是 null ，我们看这个图： 链表表示的是一列元素，它与数组的区别就在于：在链表中向序列插入和删除元素更为方便。 在表头插入结点两种方式： 创建一个结点，将它的 next 域设置为 first； 将 first 保存在 oldfirst 中，再将一个新结点赋予 first ，这里我们用 first 的 item 域存放 “not” ，把它的 next 域设置为 oldfirst ：Node oldfirst = first;first = new Node();first.item = \"not\";first.next = oldfirst; 从表头删除结点我们使 first 指向 first.next ，这样改变了 first 的值（变成了之前 first.next 结点对象的一个引用），就无法访问它曾经指向的结点了。曾经的结点对象变成了一个孤儿，Java 的内存管理系统最终将回收它所占用的内存。 first = first.next; 这条赋值语句的运行时间和链表的长度无关。 在表尾插入结点类似于在表头插入结点，还是两种方式： 创建一个结点，将之前的 last 结点的 next 域设置为这个结点； 将之前的 last 保存在 oldlast 中，设置 oldlast 的 next 域为 last ，再将一个新结点赋予 last ，这里我们用 last 的 item 域存放 “not” ：Node oldlast = last;last = new Node();last.item = \"not\";oldlast.next = last; PS: 这里需要强调一点，和在表头插入结点相同，我们创建了一个结点 oldxxx 来保存 xxx ，就是复制了一个 xxx 对象的引用 oldxxx 指向 xxx 对象的地址，相当于创建了一个别名，而不是单纯的值复制，如此一来就有 oldxxx 和 xxx 同时指向同一个对象（我们 前面 有提到过只有原始数据类型是值的复制，其他都复制的是对象的引用）。然后我们又使用 new 关键字来更新 xxx 对象，是重新为 xxx 分配了内存空间，而之前的内存空间并没有被弃用，所以不会被系统回收。 其他位置的插入和删除操作例如，我们要删除链表的尾结点就需要将它的前一个结点的 next 域设置为 null 。但我们没有其他的信息来找出这个位置，所以唯一的办法就是遍历整条链表并找出指向 last 的结点，如此所需的时间就同链表的长度成正比了。 实现任意插入和删除操作的标准解决方案就是使用 双向链表 ，每一个结点都有两个链接指向不同的方向。详见 练习 1.3.31 。 遍历我们可以这样来实现链表的迭代访问： for (Node x = first; x != null; x = x.next()) { x.item } 栈的实现在进行 push() 操作时，我们将元素添加在表头；当使用 pop() 删除一个元素时，我们将它从表头删除。 链表的使用可以达到最优设计目标： 可以处理任意类型的数据； 所需空间总是和集合大小成正比； 操作所需时间与集合大小无关。 算法 1.2&emsp;下压堆栈（链表实现） import java.util.Iterator;public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } public void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; N++; } public Item pop() { Item item = first.item; first = first.next; N--; return item; }} 自己动手写一个测试用例吧！ 队列的实现在结构化储存数据集时，链表是数组的一种重要的替代方式 。 算法 1.3&emsp;先进先出队列 import java.util.Iterator;public class Queue&lt;Item&gt; implements Iterable { private Node first; private Node last; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } public void enqueue(Item item) { Node oldLast = last; last.item = item; if (isEmpty()) first = last; else oldLast.next = last; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; }} 自己动手写一个测试用例吧！ 背包的实现算法 1.4&emsp;背包 import java.util.Iterator;public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } private void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; N++; }} 背包的链表实现就是 Stack 去掉 pop() 方法，再将它的 push() 更名为 add() 。 4. 综述 这些数据类型是其他高级数据结构的基础； 它们展示了满足性能目标所带来的挑战； 重点要支持对对象集合的强大操作。 数据结构数组和链表常被称为顺序存储和链式存储。 预告 二叉树的数据结构是含有两个链接的结点组成； 复合型数据结构：用背包储存栈，用队列储存数组； 我们可以用数组的背包来表示图。 数据结构 优点 缺点 数组 通过索引可以直接访问任意元素 在初始化时就需要知道元素的数量 链表 使用的空间和元素数量成正比 需要通过引用访问任意元素 使用抽象想数据类型解决问题： 定义 API； 根据特定场景开发用例代码； 描述一种数据结构，根据 API 定义类的实例变量； 描述算法，根据它实现类中的实例方法； 分析算法的性能特点。 补充 除了使用泛型，我们还可以构造一个 Object 对象的栈，并在 pop() 时将对象转换为所需类型。问题就是类型不匹配的错误只能在运行时发现，而使用泛型则会得到一个编译错误。 Java 中泛型数组：先了解 协变数组（convariant array）和 类型擦除（type erasure）。 创建一个字符串栈的数组（需要进行类型转换） Stack&lt;String&gt;[] a = (Stack&lt;String&gt;[]) new Stack[N]; 在我们写的代码中，栈为空时调用 pop() 会得到一个 NullPointerException 异常。 用例在迭代中调用 push() 或 pop() ，Stack 的迭代器会立即抛出一个 java.util.ConcurrentModificationException 异常。 String 没有实现 Iterable 接口，不能使用 foreach 循环访问。 习题见 习题 1-3","link":"/independent-pages/list/algs4/1/1.3/index.html"},{"title":"algs4-1.5 案例研究：union-find 算法","text":"动态连通性假设“相连”是一种等价关系，则它具有：自反性、对称性和传递性。 注： 本节使用网络方面的术语，将对象称为触点，将整数对称为连接，将等价类称为连通分量或是简称为分量。 表 1.5.1&emsp;union-find 算法的 API public class UF UF(int N) 以整数标识（0 到 N-1）初始化 N 个触点 void union(int p, int q) 在 p 和 q 之间添加一条连接 int find(int p) p（0 到 N-1）所在分量的标识符 boolean connected(int p, int q) 如果 p 和 q 存在于同一个分量中则返回 true int count() 连通分量的数量 成本模型： 数组的访问次数 。 实现quick-find 算法public class UF { private int[] id; private int count; public UF(int N) { count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; } public int count() { return count; } public boolean connected(int p, int q) { return find(p) == find(q); } public int find(int p) { return id[p]; } public void union(int p, int q) { int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++) if (id[i] == pID) id[i] = qID; count--; }} 可以引入一个测试用例： public static void main(String[] args) { int N = StdIn.readInt(); UF uf = new UF(N); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.connected(p, q)) continue; uf.union(p, q); StdOut.println(p + \" \" + q); } StdOut.println(uf.count + \"components\");} 我们使用 connected() 方法判断两个整型是否相同，来判断它们是否在同一分量中（我们将数值相等作为触点存在于同一分量的标准）。如果不在同一分量中，union() 方法会将数组中 id 与 p 相同的元素的值替换为 id[q] 的值，以此起到建立连接的作用。 具体操作如图，这样可能会更加明晰一点： quick-find 算法的分析 附： 关于本节 并查集（union-find） 的解读，可以参考这篇大牛的 博客 ，没有理解的同学可以找一下思路。 quick-find 算法解决动态连通性问题最后的到一个连通分量，那么至少需要调用 \\(N-1\\) 次 union() 方法，那么数组访问次数就是 \\((N+3)(N-1)\\) ~ \\(N^2\\) ，可以猜想 quick-find 算法是平方级别的，可见不能够很好解决数据量很大的情况。 quick-union 算法public class UF { private int[] id; private int count; public UF(int N) { count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; } public int count() { return count; } public boolean connected(int p, int q) { return find(p) == find(q); } public int find(int p) { while (p != id[p]) p = id[p]; return p; } public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) return; id[pRoot] = qRoot; count--; }} id[] 数组使用父链接的形式表示了一片森林，实际上每个触点的 id 值都表示了它的根节点或父节点的 id 值，而触点中的根触点或者说根节点的 id 值都与自己的索引值是相同的。 看图结合代码仔细想想就能明白了： 可以再观察这个例子： quick-union 算法的分析quick-union 算法是对 quick-find 算法的改良，但并不是所有情况都要比 quick-find 算法快，但它避免了操作总是线性级别的问题。quick-union 算法中的 find() 方法在最坏的情况下需要访问数组 \\(2N+1\\) 次（这里的 \\(N\\) 代指深度）。 定义： 节点的深度是它到根节点的路径上的链接数；树的大小是它的节点数量；树的高度是所有节点中的最大深度。 一种最坏的情况就是每一次的 find 操作都会进行 \\(2N+1\\) 次的数组访问，如图： 按这种操作处理，对于 \\(N\\) 对整数， find 方法就需要访问数组 \\(3+5+7+…+(2N-1)\\) ~ \\(N^2\\) 次。 加权 quick-union 算法前面的 quick-union 算法中可能会在 union() 方法中会随意将一个树连接到另一个树上，在加权实现中，我们会将较小的树连接到较大的树上，像这样： 可以再观察这个例子： public class WeightedQuickUnionUF { private int[] id; // 父链接数组 private int[] sz; // 根节点对应的分量大小 private int count; // 连通分量的数量 public WeightedQuickUnionUF(int N) { count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) id[i] = i; sz = new int[N]; for (int i = 0; i &lt; N; i++) sz[i] = 1; } public int count() { return count; } public boolean connected(int p, int q) { return find(p) == find(q); } public int find(int p) { while (p != id[p]) p = id[p]; return p; } public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) return; if (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; } else {id[j] = i; sz[i] += sz[j]; } count--; }} 加权 quick-union 算法的分析在算法中将较小的树连接到较大的树上，树的大小由 sz[] 数组的索引值来决定，初始时所有触点的分量大小为 1 。 这里要注意： 当一个触点成为根节点之后，如果它又成为了某个根节点的子节点，自身的分量数不会增加，即使将其他分量数更小的节点与这个节点建立关系，最终都会连接到它现在的根节点。 对于 \\(N\\) 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为 \\(lgN\\) 。对于加权 quick-union 算法和 \\(N\\) 个触点，在最坏情况下 find()、 connected() 和 union() 的成本的增长数量级为 \\(logN\\) 。 quick-union 算法和加权 quick-union 算法的比较 加权 quink-union 算法处理 \\(N\\) 个触点和 \\(M\\) 连接时最多访问数组 \\(cMlgN\\) 次（\\(c\\) 为常数），比起普通的 quick-union 算法的至少 \\(MN\\) 次，在在处理大规模动态连通性问题时要快许多。 各种 union-find 算法的性能特点 最优算法有一种能够保证在常数时间内完成各种操作的算法，就是使用 路径压缩 的方式。这样做就是要在检查节点的同时将它们直接链接到根节点，只需要在 find() 里添加一个循环实现操作。但这里要注意，使用路径压缩的加权 quick-union 算法的每个操作在最坏情况下都不是常数级别的（均摊后），但这已经是我们能给出的最优解了。 find() 方法的实现： public int find(int p) { int current = p, t; while (p != id[p]) p = id[p]; // 将当前节点的每代父节点都链接到根节点上（但不会改变它的子节点） while (current != p) { t = id[current]; id[current] = p; current = t; } return p;} 补充 cell-probe 是一种计算模型，我们只会记录对随机内存的访问，内存的大小足以保存所有输入且假设其他操作均没有成本。 习题见 习题 1-5","link":"/independent-pages/list/algs4/1/1.5/index.html"},{"title":"algs4-2.1 初级排序算法","text":"在创建数据类型时，只要实现 Comparable 接口就能够保证用例代码可以将其排序。要做到这点就要实现 compareTo() 方法来定义目标类型的自然次序。 排序类算法的模版： public class Example { public static void sort(Comparable[] a) { } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } private static void show(Comparable[] a) { for (int i = 0; i &lt; a.length; i++) StdOut.print(a[i] + \" \"); StdOut.println(); } public static boolean isSorted(Comparable[] a) { for (int i = 1; i &lt; a.length; i++) if (less(a[i], a[i - 1])) return false; return true; } public static void main(String[] args) { String[] a = In.readStrings(); sort(a); assert isSorted(a); show(a); }} Java 的习惯是在 compareTo() 方法被调用时返回一个负整数、零和一个正整数（一般是 -1 、0 和 1）。在两者无法进行比较或者其中一方为 null 时，方法会抛出一个异常。此外，compareTo() 必须实现一个 全序关系 ： 自反性，对于所有 v ，v = v ； 反对称性，对于所有 v &gt; w 都有 v &lt; w ，且 v = w 时，w = v ； 传递性，对于所有 v 、w 和 x ，如果 v &lt;= w 且 w &lt;= x ，则有 v &lt;= x 。 选择排序找到数组中最小的那个元素，将它和数组的第一个元素进行交换，如此往复… 对于长度为 \\(N\\) 的数组来说，选择排序需要大约 \\(N^2/2\\) 次比较和 \\(N\\) 次交换 比较次数：\\((N-1)+(N-2)+…+2+1=\\frac{N(N-1)}{2}\\) ~ \\(N^2/2\\) 特点 运行时间和输入无关： 一个有序或主键全部相等的数组和一个元素随机排列的数组所用的排序时间几乎一样长； 数据移动最少： 进行了 \\(N\\) 次交换，交换次数和数组大小是线性关系。 算法 2.1&emsp;选择排序 public class Selection { public static void sort(Comparable[] a) { int N = a.length; for (int i = 0; i &lt; N; i++) { int min = i; for (int j = i + 1; j &lt; N; j++) if (less(a[i], a[min])) min = j; exch(a, i, min); } } // less()、exch()、isSorted() 和 main() 方法见模版} 插入排序和选择排序不同的是，插入排序的时间取决于输入中元素的初始顺序。在实际应用中对于某些类型的非随机数组很有效，对于有序数组，它的耗时是线性的。 对于随机排列长度为 \\(N\\) 且主键不重复的数组，平均需要进行 ~ \\(N^2/4\\) 次比较以及 ~ \\(N^2/4\\) 次交换。最坏情况下要进行 ~ \\(N^2/2\\) 次比较和 ~ \\(N^2/2\\) 次交换，最好情况下要 \\(N-1\\) 次比较和 \\(0\\) 次交换。 算法 2.2&emsp;插入排序 public class Insertion { public static void sort(Comparable[] a) { int N = a.length; for (int i = 1; i &lt; a.length; i++) { for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j - 1]); j--) exch(a, j, j - 1); } } // less()、exch()、isSorted() 和 main() 方法见模版} 部分有序数组： 数组中每个元素离它最终位置不远； 一个有序大数组接一个小数组； 数组中只有几个元素的位置不正确。 插入排序对这样的数组很有效，而选择排序不然。当倒置的数量很少时，插入排序很可能比其他绝大部分算法都要快。 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。 想要提高插入排序的速度，可以在内循环中将较大的元素向右移动而不是交换两个元素（访问数组的次数会减半）。 排序算法的可视化因为插入排序不会移动比被插入元素更小的元素，它所需要的比较次数平均只有选择排序的一半。 比较两种排序算法 实现并调试它们； 分析它们的基本性质； 对它们的相对性能作出猜想； 用实验证明我们的猜想。 对于随机排序的数组，两者的运行时间都是平方级别的。 \\(N^2\\) 前面的常数值取决于计算机中比较和交换元素的成本，而对于许多数据类型和一般的计算机，假设这些成本是接近的，可以得出猜想： 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。 比较两种排序算法 public class SortCompare { // 针对给定输入，为排序算法计时 ⌛️ public static double time(String alg, Comparable[] a) { Stopwatch timer = new Stopwatch(); if (alg.equals(\"Insertion\")) Insertion.sort(a); if (alg.equals(\"Selection\")) Selection.sort(a); if (alg.equals(\"Shell\")) Shell.sort(a); if (alg.equals(\"Merge\")) Merge.sort(a); if (alg.equals(\"Quick\")) Quick.sort(a); if (alg.equals(\"Heap\")) Heap.sort(a); return timer.elapsedTime(); } public static double timeRandomInput(String alg, int N, int T) { // 使用算法 alg 将 T 个长度为 N 的数组排序 double total = 0.0; Double[] a = new Double[N]; // 生成随机数组并排序 for (int t = 0; t &lt; T; t++) a[i] = StdRandom.uniform(); total += time(alg, a); } public static void main(String[] args) { String alg1 = args[0]; String alg2 = args[1]; int N = Integer.parseInt(args[2]); int T = Integer.parseInt(args[3]); double t1 = timeRandomInput(alg1, N, T); double t1 = timeRandomInput(alg2, N, T); StdOut.printf(\"For %d random Doubles\\n %s is\", N, alg1); StdOut.printf(\" %.1f times faster than %s\\n\", t2 / t1, alg2); }} 对于初级算法 建立了一些基本规则； 展示了一些性能标准； 在某些情况下是很好的选择； 是更强大算法的基石。 希尔排序希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组，是由 h 个相互独立的有序数组编织在一起组成的。 实现希尔排序的一种方法就是对于每个 h ，用插入排序将 h 个子数组独立地排序，排序之后的子数组都是部分有序的。 算法 2.3&emsp;希尔排序 public class Shell { public static void sort(Comparable[] a) { int N = a.length; int h = 1; while (h &lt; N / 3) h = 3 * h + 1; while (h &gt;= 1) { for (int i = h; i &lt; N; i++) { for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) exch(a, j, j - h); } h = h / 3; } } // less()、exch()、isSorted() 和 main() 方法见模版} 与选择排序和插入排序形成对比的是，希尔排序也可以用于大型数组，对任意排序的数组表现也很好。 通过 SortCompare 可以看到，希尔排序比选择和插入排序要快得多，而且数组越大优势越明显。对于 算法 2.3 ，目前只知道它的运行时间不到平方级别。 使用递增序列 1，4，13，40，121，364… 的希尔排序所需的比较次数不会超出 \\(N \\) 的若干倍乘以递归序列的长度。平均每个增幅带来的比较次数约为 \\(N^{1/5}\\) ，但只有在 \\(N\\) 很大的时候才明显。 如果需要解决一个排序问题而又没有系统排序函数可用（例如直接解除硬件或是运行与嵌入式系统中的代码），可以先用希尔排序，再考虑是否值得替换为更复杂的排序算法。 补充 less() 和 exch() 这些函数使代码更容易理解，而且增强了代码的可移植性。只要将 less() 实现为 v &lt; w 就可以给不支持 Comparable 接口的基本数据类型排序了。 习题见 习题 2-1","link":"/independent-pages/list/algs4/2/2.1/index.html"},{"title":"algs4 习题 1-3","text":"练习1. isFull() 方法public boolean isFull() { return N == a.length; } 2. java Stack 的输出was best times of the was the it 3. 不可能产生的出栈返回值 a. 0 1 2 3 4 - - - - - 5 6 7 8 9 - - - - - b. 0 1 2 3 4 - 5 6 - 7 8 - - - - - 9 - - -4 6 8 7 5 3 2 9 1 0 c. 0 1 2 - 3 4 5 - 6 - 7 - - 8 - 9 - - - - d. 0 1 2 3 4 - - - - - 5 - 6 - 7 - 8 - 9 - e. 0 1 - 2 - 3 - 4 - 5 - 6 - 7 8 9 - - - - f. 0 - 1 2 3 4 - 5 6 - - - 7 8 - - - - 9 -0 4 6 5 3 8 7 2 1 9 g. 0 1 - 2 3 4 - 5 6 7 - 8 9 - - - - - - -1 4 7 9 8 6 5 3 2 0 h. 0 1 2 - - 3 4 - - 5 6 - - 7 8 - - 9 - - 4. 用例 Parenthesespublic class Parentheses { public static void main(String[] args) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); while_loop: while (!StdIn.isEmpty()) { char c = StdIn.readChar(); if (c == '{' || c == '[' || c == '(') { stack.push(c); } else if (c == '}' || c == ']' || c == ')') { if (!stack.isEmpty()) { switch (c) { case '}': if (stack.pop() != '{') { StdOut.println(false); System.exit(0); } case ']': if (stack.pop() != '[') { StdOut.println(false); System.exit(0); } case ')': if (stack.pop() != '(') { StdOut.println(false); System.exit(0); } default: break; } } else { StdOut.println(false); System.exit(0); } } } StdOut.println(true); }} 简述： 在用例中 stack 栈只存入左半部分的括号； 根据括号匹配的原则，每一个右括号都应该同栈中 pop() 出来的左括号相匹配； 这个用例在使用时，如果右括号检查匹配失败，会自动结束输入； 如果括号完全匹配，最后栈为空； 如果输入中没有括号的存在，同样返回 true 值。 5. 打印结果打印 N 的二进制表示。 6. 对 q 的操作将 q 中的与元素逆序排列。 7. 方法 peek()public Item peek() { return first.item;} 8. 数组内容和大小it ，大小为 1 。 9. 中序表达式public class Infix { public static void main(String[] args) { Stack&lt;String&gt; ops = new Stack&lt;&gt;(); Stack&lt;String&gt; vals = new Stack&lt;&gt;(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); if (s.equals(\"+\")) ops.push(s); else if (s.equals(\"-\")) ops.push(s); else if (s.equals(\"*\")) ops.push(s); else if (s.equals(\"/\")) ops.push(s); else if (s.equals(\")\")) { if (!vals.isEmpty()) { String s2 = vals.pop(); String s1 = vals.pop(); vals.push(\"( \" + s1 + \" \" + ops.pop() + \" \" + s2 + \" )\"); } } else { vals.push(s); } } for (String s : vals) StdOut.print(s); }} 简述： ops 栈用来保存操作符号； vals 栈用来保存非操作符的内容（数值或数值操作符括号组合）； 正常执行的前提是按格式标准输入。 10. 过滤器 InfixToPostfixpublic class InfixToPostfix { public static void main(String[] args) { Stack&lt;String&gt; ops = new Stack&lt;&gt;(); Stack&lt;String&gt; vals = new Stack&lt;&gt;(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); if (s.equals(\"(\")); else if (s.equals(\"+\")) ops.push(s); else if (s.equals(\"-\")) ops.push(s); else if (s.equals(\"*\")) ops.push(s); else if (s.equals(\"/\")) ops.push(s); else if (s.equals(\")\")) { String s2 = vals.pop(); String s1 = vals.pop(); vals.push(s1 + \" \" + s2 + \" \" + ops.pop()); } else { vals.push(s); } } for (String s : vals) StdOut.print(s); }} 请按如下格式进行输入：( ( ( 2 * 3 ) / ( 2 - 1 ) ) + ( 3 * ( 4 - 1 ) ) ) 输出结果：2 3 * 2 1 - / 3 4 1 - * + 11. 后序表达式计算 EvaluatePostfixpublic class EvaluatePostfix { public static void main(String[] args) { Stack&lt;String&gt; ops = new Stack&lt;&gt;(); Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); while (!StdIn.isEmpty()) { String s = StdIn.readString(); if (s.equals(\"+\")) { double val = vals.pop(); vals.push(vals.pop() + val); } else if (s.equals(\"-\")) { double val = vals.pop(); vals.push(vals.pop() - val); } else if (s.equals(\"*\")) { double val = vals.pop(); vals.push(vals.pop() * val); } else if (s.equals(\"/\")) { double val = vals.pop(); vals.push(vals.pop() / val); } else vals.push(Double.parseDouble(s)); } StdOut.println(vals.pop()); }} 12. 有静态方法 copy() 的 Stack 用例这里使用了迭代器和 foreach 循环。 public static Stack&lt;String&gt; copy(Stack&lt;String&gt; stack) { Iterator&lt;String&gt; iterator = stack.iterator(); Stack&lt;String&gt; res = new Stack&lt;&gt;(); Stack&lt;String&gt; temp = new Stack&lt;&gt;(); if (iterator.hasNext()) temp.push(iterator.next()); for (String s : stack) res.push(s); return res;} 13. 不可能产生的出列返回值根据队列先进先出的特点，所以只有 a 是可能实现的。 14. 类 ResizingArrayQueueOfStringspublic class ResizingArrayQueueOfStrings { private String[] a; private int N; private int first; private int last; public ResizingArrayQueueOfStrings() { a = new String[2]; N = 0; first = 0; last = 0; } public boolean isEmpty() { return N == 0; } public int size() { return N; } private void resize(int max) { String[] temp = new String[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[(first + 1) % a.length]; } a = temp; first = 0; last = N; } public void enqueue(String s) { if (N == a.length) resize(2 * a.length); a[last++] = s; N++; } public String dequeue() { String s = a[first]; a[first] = null; N--; first++; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return s; }} 15. Queue 用例public static void main(String[] args) { Queue&lt;String&gt; q = new Queue&lt;&gt;(); int k = Integer.parseInt(args[0]); while (!StdIn.isEmpty()) { String s = StdIn.readString(); q.enqueue(s); } for (int i = 0; i &lt; (q.size() + 1 - k); i++) { if (i == q.size() - k) { StdOut.println(q.dequeue()); break; } q.dequeue(); }} 16. 静态方法 readDates()public static Date[] readDates() { Queue&lt;Date&gt; q = new Queue&lt;&gt;(); while (!StdIn.isEmpty()) { String[] str = StdIn.readString().split(\"/\"); int month = Integer.parseInt(str[0]); int day = Integer.parseInt(str[1]); int year = Integer.parseInt(str[2]); q.enqueue(new Date(year, month, day)); } int N = q.size(); Date[] a = new Date[N]; for (int i = 0; i &lt; N; i++) a[i] = q.dequeue(); return a;} 17. 对 Transaction 的实现我在 Date 里写了一个静态方法 readDate(String s) 用来对读入的字符串进行处理，返回一个 Date 对象： public static Date readDate(String s) { String[] str = s.split(\"/\"); int month = Integer.parseInt(str[0]); int day = Integer.parseInt(str[1]); int year = Integer.parseInt(str[2]); return new Date(year, month, day);} Transaction 中的静态方法 readTransactions() 是这样写的，同上面的 readDates() 方法类似，比它稍微复杂了一点： public static Transaction[] readTransactions() { Queue&lt;Transaction&gt; q = new Queue&lt;&gt;(); while (!StdIn.isEmpty()) { String name = StdIn.readString(); Date date = Date.readDate(StdIn.readString()); double amount = Double.parseDouble(StdIn.readString()); q.enqueue(new Transaction(name, date, amount)); } int N = q.size(); Transaction[] a = new Transaction[N]; for (int i = 0; i &lt; N; i++) a[i] = q.dequeue(); return a;} 链表练习18. 语句的效果x.next 指向了 x.next.next ，之前的 x.next 就变成了孤儿，会被 Java 回收，相当于删除了 x 的后续结点。 19. 删除链表的尾结点Node current = first;while (current.next.next != null) { current = current.next;}current.next = null; 20. 方法 delete()public void delete(int k) { Node current = first; for (int i = 0; i &lt; k - 2; i++) { current = current.next; if (current == null) break; } if (current.next != null) current.next = current.next.next;} 21. 方法 find()public boolean find(Chain&lt;String&gt; c, String s) { // 前提是链表中的 first 属性为 public Node current = c.first; for (int i = 0; i &lt; c.size(); i++) { if (s.equals(current.item)) return true; if (i != c.size() - 1) current = current.next; } return false;} 22. 代码做了什么将 t 插入 x 与 x.next 之间。 23. 为什么效果不同x.next 已经替换为 t ，x.next 指向 t 本身，不再与曾经的后续结点有关。 24. 方法 removeAfter()public void removeAfter(Node node) { if (node != null &amp;&amp; node.next != null) node.next = null;} 25. 方法 insertAfter()public void insertAfter(Node node_1, Node node_2) { if (node_1 != null &amp;&amp; node_2 != null) { node_2.next = node_1.next; node_1.next = node_2; }} 26. 方法 remove()public void remove(Chain&lt;String&gt; c, String s) { Node current = c.first; for (int i = 0; i &lt; c.size(); i++) { if (current.next == null) break; if (item.equals(current.next.item)) current.next = current.next.next; }}","link":"/independent-pages/src/algs4/1/1.3/index.html"},{"title":"algs4 习题 1-5","text":"练习1. 给出数组内容和访问次数只需将方法这样改写一下： private int n = 0;public int find(int index) { n++; return id[index];}public void union(int p, int q) { int pID = find(p); int qID = find(q); if (pID == qID) { for (int i = 0; i &lt; id.length; i++) System.out.print(id[i] + \" \"); System.out.printf(\"[%d]\\n\", n); return; } for (int i = 0; i &lt; id.length; i++) { if (id[i] == pID) id[i] = qID; n++; } for (int i = 0; i &lt; id.length; i++) System.out.print(id[i] + \" \"); System.out.printf(\"[%d]\\n\", n); count--;} 测试用例可以这样弄： public static void main(String[] args) { int N = StdIn.readInt(); UF uf = new EX1(N); while (!StdIn.isEmpty()) { int p = StdIn.readInt(); int q = StdIn.readInt(); uf.union(p, q); } StdOut.println(uf.count + \"components\");} 2. 完成 quick-union 算法与 练习1.5.1 用例相同 private int n = 0;public int find(int p) { while (p != id[p]){ p = id[p]; n++; } return p;}public void union(int p, int q) { int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot){ for (int i = 0; i &lt; id.length; i++) System.out.print(id[i] + \" \"); System.out.printf(\"[%d]\\n\", n); return; } id[pRoot] = qRoot; n++; for (int i = 0; i &lt; id.length; i++) System.out.print(id[i] + \" \"); System.out.printf(\"[%d]\\n\", n); count--;} 画出每次 id[] 数组表示的森林吧～ 3. 完成加权 quick-union 算法private int n = 0;public int find(int p) { int current = p, t; while (p != id[p]) { p = id[p]; n++; } while (current != p) { t = id[current]; id[current] = p; current = t; n += 2; } return p;}public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) { for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n); return; } if (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; n++; for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n); } else { id[j] = i; sz[i] += sz[j]; n++; for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n); } count--;} 4. 添加 sz[] 数组的操作private int n1 = 0. n2 = 0;public int find(int p) { int current = p, t; while (p != id[p]) { p = id[p]; n1++; } while (current != p) { t = id[current]; id[current] = p; current = t; n1 += 2; } return p;}public void union(int p, int q) { int i = find(p); int j = find(q); if (i == j) { for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n1); for (int index = 0; index &lt; sz.length; index++) System.out.print(sz[index] + \" \"); System.out.printf(\"[%d]\\n\", n2); return; } if (sz[i] &lt; sz[j]) { id[i] = j; sz[j] += sz[i]; n1++; n2 += 2; for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n1); for (int index = 0; index &lt; sz.length; index++) System.out.print(sz[index] + \" \"); System.out.printf(\"[%d]\\n\", n2); } else { id[j] = i; sz[i] += sz[j]; n1++; n2 += 2; for (int index = 0; index &lt; id.length; index++) System.out.print(id[index] + \" \"); System.out.printf(\"[%d]\\n\", n1); for (int index = 0; index &lt; sz.length; index++) System.out.print(sz[index] + \" \"); System.out.printf(\"[%d]\\n\", n2); } count--;} 5. 估算时间\\(sum \\approx 10^9 \\times 10^6 \\times 10 \\times 10^9 = 10^{25}\\) \\(T = sum \\div 10^9 \\div 3600 \\div 24 \\approx 116\\ days\\) 6. 估算时间\\(sum \\approx lg10^9 \\times 10 \\times 10^6 = 9 \\times 10^7\\) \\(T = sum \\div 10^9 \\approx 0.1\\ s\\) 7. 类的实现前面都有提到，这里就不再赘述了。 8. 错在哪里没有将 id[i] 同 p 的根节点 ID 进行比较，不能实现将两条多触点链连接在一起。 9. 可不可能已经有同学将对应的树画出来了： 原文链接：https://www.cnblogs.com/songdechiu/p/6561636.html 对于加权的 quick-union 算法来说，需要将小的树连接到大的树上。如果是先将 6 和成型的 5 建立连接，那么 6 应该连接到 5 上面才对；而如果现将 5 和成型的 6 建立连接，那么 5 应该与 6 的根节点 1 建立连接。按这种思路进行推理… 10. 是否正确这样做是正确的，不过可能会将一个小的树直接连接在另一个树的树叶上，增加了树的高度，不能保证性能。 11. 影响这样做增加了 find() 操作的成本，增加了数组的访问次数，每一次 find() 操作都会消耗大量的时间成本。","link":"/independent-pages/src/algs4/1/1.5/index.html"},{"title":"algs4 习题 2-1","text":"练习1. 排序过程 2. 交换次数交换的平均次数为 1，最多被交换 \\(N\\) 次。 最多交换次数： 3. 构造数组若使 a[j] &lt; a[min] 成功次数最大，可以让它是一个完全逆序排列的数组。 4. 排序过程 5. 构造数组内层 for 循环的判断条件是 j &gt; 0 &amp;&amp; less(a[j], a[j - 1]) ，我们可以使 less() 方法每一次的判断都是假的，那么数组就需要顺序排列，或是部分主键相同。 6. 谁更快 ？在主键相同时，插入排序的时间是线性的。而对于选择排序则是平方级别的。 7. 谁更快 ？数组是逆序的，对于插入排序来说就意味着内层 for 循环每一次都要进行到底，时间是平方级别的（交换次数为平方级别）。而对于选择排序来说，数组元素的交换次数在 \\(N/2\\) 左右。 8. 运行时间平方级别。随机数组意味着三种值出现的概率相同，那么外层 for 循环遍历到的每个元素 \\(N\\) 都有可能进行 \\(N/3\\) 次交换。 9. 排序过程 10. 为什么不使用选择排序 ？对于 h 有序，插入排序在部分有序的条件下要比选择排序好很多。 11. 预先计算将 h 的序列保存在一个数组中即可。 12. 打印创建一个 \\(N\\) 个元素的数组，对每个元素的比较次数进行记录。","link":"/independent-pages/src/algs4/2/2.1/index.html"},{"title":"algs4-2.2 归并排序","text":"归并排序最吸引人的性质就是能够保证长度为 \\(N\\) 的数组排序所需时间和 \\(NlogN\\) 成正比；缺点是所需的额外空间和 \\(N\\) 成正比。 原地归并将数组拆分成两个部分。操作完成后，左半部分小于等于右半部分。 public static void merge(Compareable[] a, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) // 这是 Merge 类的一个方法，aux[] 在方法外部定义 aux[k] = a[k]; for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; }} 自顶向下的归并排序实现了递归归并，是应用高效算法设计中 分治思想 的最典型的一个例子。 public class Merge { private static Compareable[] aux; public static void sort(Compareable[] a) { aux = new Compareable[a.length]; sort(a, 0, a.length - 1); } private static void sort(Compareable[] a, int lo, int hi) { if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } public static void merge(Compareable[] a, int lo, int mid, int hi) { }} 每个小部分通过递归调用将它们单独排序。 命题：对于长度为 \\(N\\) 的任意数组，自顶向下的归并排序需要 \\(\\frac{N}{2}lgN\\) 至 \\(NlgN\\) 次比较。 证明：用 \\(C(N)\\) 表示长度为 \\(N\\) 的数组排序时所需要的比较次数，有 \\(C(0) = C(1) = 0\\) 。 比较次数上限： $$C(N) \\leq C(N/2) + C(N/2) + N$$ 前两项为左右两边排序所用的比较次数，第三项为归并所用的比较次数。 比较次数下限： $$C(N) \\geq C(N/2) + C(N/2) + N/2$$ 当 \\(N = 2^n\\) 时， \\(N/2 = 2^{n-1}\\) ，有： $$C(2^n) = 2C(2^{n-1}) + 2^n$$ 两边同时除以 \\(2^n\\) ： $$C(2^n)/2^n = C(2^{n-1}) / 2^{n-1} + 1$$ 替换： $$C(2^n)/2^n = C(2^{n-2}) / 2^{n-2} + 1 + 1$$ 重复 n-1 遍得： $$C(2^n) / 2^n = C(2^0) / 2^0 + n$$ 两边同时乘以 \\(2^n\\) 得： $$C(N) = C(2^n) = n2^n = NlgN$$ 换一种方式理解：下面的树就有 \\(n\\) 层，对于 \\(0\\) 到 \\(n - 1\\) 之间的任意 \\(k\\) ，自顶向下第 \\(k\\) 层有 \\(2^k\\) 个子数组，每个数组的长度为 \\(2^{k-n}\\) ，归并最多需要 \\(2^{k-n}\\) 次比较。每层的比较次数就是 \\(2^k \\times 2^{k-n} = 2^n\\) ，\\(n\\) 层总共为 \\(n2^n = NlgN\\) 。 命题：对于长度为 \\(N\\) 的任意数组，自底而上的归并排序需要 \\(1/2NlgN\\) 至 \\(NlgN\\) 次比较，最多访问数组 \\(6NlgN\\) 次。（每一遍会访问数组 \\(6N\\) 次，比较次数在 \\(N/2\\) 和 \\(N\\) 之间） 当数组长度为 2 的幂时，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数刚好相同，只是顺序不同。 对于自底而上的实现方式，它比较适合用链表组织的数据，这种方法只需要重新组织链表链接就能进行原地排序。 排序算法的复杂度注意：本章的排序算法都是基于主键的比较，局限于实现了 Compareable 接口的对象，忽略了访问数组的开销。 命题：没有任何基于比较的算法能够保证使用少于 \\(lg(N!)\\) ~ \\(NlgN\\) 次比较将长度为 \\(N\\) 的数组排序。 证明：对于 \\(N\\) 个不同的主键，有 \\(N!\\) 种不同的排列。这是一个 \\(N = 3\\) 时的比较树： ，表示排序完成前的原输入顺序；要么是一个内部结点 命题：归并排序是一种渐进最优的基于比较的排序算法。 本节中理论的局限性： 归并排序的空间复杂度不是最优的； 在实践中不一定会遇到最坏情况； 除了比较，算法的其他操作（例如访问数组）也可能很重要； 不进行比较也能将某些数据排序。 补充 更好的解决方案：将 aux[] 变为 sort() 方法的局部变量，并将它作为参数传递给 merge() 方法。 所有元素相同时，归并排序的运行时间是线性的。 习题见 习题 2-2","link":"/independent-pages/list/algs4/2/2.2/index.html"},{"title":"algs4 习题 1-2","text":"练习 部分用例的用法 % javac Testxxx.java% java Testxxx [args] 以下出现 Integer.parseInt(args[x]) 的地方均可以替换为 StdIn.readxxx() ，不过这样变成了从标准输入中读取数据。题中要求从命令行接受数据，所以最好避免从标准输入中进行数据的获取。 1. Point2D 用例public class TestPoint2D { public static void main(String[] args) { int N = Integer.parseInt(args[0]); Point2D[] points = new Point2D[N]; for (int i = 0; i &lt; N; i++) { points[i] = new Point2D(Math.random(), Math.random()); points[i].draw(); } if (N &gt; 1) { double min = points[0].distanceTo(points[1]); for (int i = 0; i &lt; N - 1; i++) { for (int j = i + 1; j &lt; N; j++) { if (points[i].distanceTo(points[j]) &lt; min) { min = points[i].distanceTo(points[j]); } } } System.out.println(\"The min distance: \" + min); } }} 2. Interval1D 用例public class TestInterval1D { public static void main(String[] args) { int N = Integer.parseInt(args[0]); Interval1D[] intervals = new Interval1D[N]; for (int i = 0; i &lt; N; i++) { intervals[i] = new Interval1D(StdIn.readDouble(), StdIn.readDouble()); } for (int i = 0; i &lt; N - 1; i++) { for (int j = i + 1; j &lt; N; j++) { if (intervals[i].intersects(intervals[j])) { StdOut.println(intervals[i] + \" -- \" + intervals[j]); } } } }} 3. Interval2D 用例public class TestInterval2D { private static int intersectCount = 0; private static int containCount = 0; private static double max(double a, double b) { return Math.max(a, b); } private static double min(double a, double b) { return Math.min(a, b); } public static void main(String[] args) { int N = Integer.parseInt(args[0]); double min = Double.parseDouble(args[1]); double max = Double.parseDouble(args[2]); // 设置绘图范围（可以保证所有矩形都绘制在窗格内） StdDraw.setXscale(min, max); StdDraw.setYscale(min, max); // 供判断 contains 条件的点集合 Point2D[] leftTopPoints = new Point2D[N]; Point2D[] rightBottomPoints = new Point2D[N]; Interval2D[] interval2DS = new Interval2D[N]; for (int i = 0; i &lt; N; i++) { double x1 = StdRandom.uniform(min, max); double x2 = StdRandom.uniform(min, max); double y1 = StdRandom.uniform(min, max); double y2 = StdRandom.uniform(min, max); leftTopPoints[i] = new Point2D(min(x1, x2), min(y1, y2)); rightBottomPoints[i] = new Point2D(max(x1, x2), max(y1, y2)); interval2DS[i] = new Interval2D(new Interval1D(min(x1, x2), max(x1, x2)), new Interval1D(min(y1, y2), max(y1, y2))); interval2DS[i].draw(); } for (int i = 0; i &lt; N - 1; i++) { for (int j = 1; j &lt; N; j++) { if (interval2DS[i].intersects(interval2DS[j])) { intersectCount++; } if (interval2DS[i].contains(leftTopPoints[j]) &amp;&amp; interval2DS[i].contains(rightBottomPoints[j])) { containCount++; } } } StdOut.println(\"Intersect count: \" + intersectCount); StdOut.println(\"Contain count: \" + containCount); }} 4. 单纯的值传递worldhello 5. String 对象不可变所有的字符串方法都不会改变参数对象的值，而是返回一个新的 String 对象。 6. 回环变位 书中提示的方法 if ((s + s).indexOf(t) &gt;= 0) {}; 使用了字符串拼接的方法 if (s.concat(s).contains(t)) {}; 7. 递归函数的返回值返回一个倒序的字符串。 8. 数组引用复制的是引用，不是数据。原始数据类型才会将数据复制下来，其余复制的都是对象的引用。 9. BinarySearch 中增加 Counter我这里又定义了一个 Counter 类，以便于对记录值进行修改。 class Counter { private int val = 0; public int getVal() { return val; } public void add() { val++; }}public class BinarySearch { public static int rank(int key, int[] a, Counter counter) { return rank(key, a, 0, a.length - 1, counter); } public static int rank(int key, int[] a, int lo, int hi, Counter counter) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { counter.add(); return rank(key, a, lo, mid - 1, counter); } else if (key &gt; a[mid]) { counter.add(); return rank(key, a, mid + 1, hi, counter); } else { counter.add(); return mid; } } public static void main(String[] args) { Counter counter = new Counter(); int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.println(rank(6, a, counter)); System.out.println(counter.getVal()); }} 10. 类 VisualCounter 实现： public class VisualCounter { private int val; private int N; private int max; // 用来记录操作次数 private int counter = 0; public VisualCounter(int N, int max) { this.N = N; this.max = max; StdDraw.setXscale(0, N); StdDraw.setYscale(0, max); StdDraw.setPenColor(StdDraw.RED); StdDraw.setPenRadius(.01); } public void add() { if (val &lt; max &amp;&amp; counter &lt; N) val++; StdDraw.point(counter, val); counter++; } public void reduce() { if (counter &lt; N) val--; StdDraw.point(counter, val); counter++; }} 用例： public class TestVisualCounter { public static void main(String[] args) { VisualCounter counter = new VisualCounter(100, 100); for (int i = 0; i &lt; 50; i++) { counter.add(); } for (int i = 0; i &lt; 30; i++) { counter.reduce(); } for (int i = 0; i &lt; 20; i++) { counter.add(); } }} 11. SmartDate 类这里定义了 年-月-日-时-分-秒 这六个变量，设置了四个构造器，提供了对变量进行操作和得到当前星期的方法。因为代码比较易懂，所以这里就不会多作说明了。书上 表1.2.12 中 Date 类的另一种实现还挺有意思的，有兴趣的同学可以看一下，另外还可以阅读 edu.princeton.cs.algs4 包中 Date 类的 源码 。 当日期信息错误时，会报异常：java.lang.IllegalArgumentException: Illegal date message.当时间信息错误时，会报异常：java.lang.IllegalArgumentException: Illegal time message. PS: 没有注意到书中提供的 Date 的 API 😂，所以可能同书中的要求有所不同，变化不大，就不作修改了。 实现： public class SmartDate { private int year; private int month; private int date; private int hrs; private int min; private int sec; public SmartDate(int year, int month, int date) { this(year, month, date, 0, 0, 0); } public SmartDate(int year, int month, int date, int hrs) { this(year, month, date, hrs, 0, 0); } public SmartDate(int year, int month, int date, int hrs, int min) { this(year, month, date, hrs, min, 0); } public SmartDate(int year, int month, int date, int hrs, int min, int sec) { if (year &gt;= 0) { switch (month) { default: if (hrs &gt;= 0 &amp;&amp; hrs &lt;= 23) { if (min &gt;= 0 &amp;&amp; min &lt;= 59) { if (sec &gt;= 0 &amp;&amp; sec &lt;= 59) { this.hrs = hrs; this.min = min; this.sec = sec; } } } else { throw new IllegalArgumentException(\"Illegal time message.\"); } case 1: case 3: case 5: case 7: case 8: case 10: case 12: if (date &gt;= 1 &amp;&amp; date &lt;= 31) { if (hrs &gt;= 0 &amp;&amp; hrs &lt;= 23) { this.year = year; this.month = month; this.date = date; } } else { throw new IllegalArgumentException(\"Illegal date message.\"); } break; case 4: case 6: case 9: case 11: if (date &gt;= 1 &amp;&amp; date &lt;= 30) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } break; case 2: if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) { if (date &gt;= 1 &amp;&amp; date &lt;= 29) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } else { if (date &gt;= 1 &amp;&amp; date &lt;= 28) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } } } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } public int getDayOfWeek() { return (date + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400) % 7; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getMonth() { return month; } public void setMonth(int month) { this.month = month; } public int getDate() { return date; } public void setDate(int date) { this.date = date; } public int getHrs() { return hrs; } public void setHrs(int hrs) { this.hrs = hrs; } public int getMin() { return min; } public void setMin(int min) { this.min = min; } public int getSec() { return sec; } public void setSec(int sec) { this.sec = sec; }} 测试用例： public class TestSmartDate { public static void main(String[] args) { SmartDate date = new SmartDate(2019, 8, 27); System.out.println(date.getDayOfWeek()); }} 12. 方法 dayOfTheWeek()上面已经有了 SmartDate 类的源码，这里只给出方法的实现。 public String dayOfTheWeek() { int index = (date + 1 + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400) % 7; switch (index) { case 0: return \"Sunday\"; case 1: return \"Monday\"; case 2: return \"Tuesday\"; case 3: return \"Wednesday\"; case 4: return \"Thursday\"; case 5: return \"Friday\"; case 6: return \"Saturday\"; default: return null; }} 13. Transaction 类型参考了一下 edu.princeton.cs.algs4 包里的 Transaction 类，发现写这个类型是为了记录交易信息，类中包含了 人-时间-交易数目 。有兴趣的同学可以阅读 edu.princeton.cs.algs4 包中 Transaction 类的 源码 。 // 刚刚才写了 SmartDate 类，那我们就使用它来代替 Date 吧！public class Transaction { private final String who; private final SmartDate date; private final double amount; public Transaction(String name, SmartDate date, double amount) { who = name; this.date = date; this.amount = amount; } public String who() { return who; } public SmartDate date() { return date; } public double amount() { return amount; } public String toString() { return who() + \"/\" + date() + \"/\" + amount(); }} 14. Transaction 类的 equals() 方法这个方法是完全仿照书上 Date 类中的 equals() 方法写的。 public boolean equals(Object x) { if (this == x) return true; if (x == null) return false; // 如果两者的类型不同则返回 false 值 if (this.getClass() != x.getClass()) return false; // 类型转换 Transaction that = (Transaction) x; if (this.who != that.who) return false; if (this.date != that.date) return false; if (this.amount != that.amount) return false; return true;} 提高题 待更新","link":"/independent-pages/src/algs4/1/1.2/index.html"},{"title":"algs4 习题 2-2","text":"练习1. 原地归并的排序过程 A&emsp;E&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;S&emsp;U&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;U&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;Y&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;E&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;I&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;S&emsp;N&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;S&emsp;U&emsp;O&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;S&emsp;T A&emsp;E&emsp;E&emsp;I&emsp;N&emsp;O&emsp;Q&emsp;S&emsp;U&emsp;Y&emsp;S&emsp;T 2. 自顶向下排序过程 3. 自底向上的排序过程 4. 原地归并的结果原地归并只是将整个数组分成了两个部分，这两个部分中左半边始终小于等于右半边。所以得到的结果可能是有序的，但却不一定，取决于调用方法前的数组排列顺序。 5. 子数组大小和顺序 自顶向下： 2 3 2 5 2 3 2 5 10 2 3 2 5 2 3 2 5 10 20 2 3 2 5 2 3 2 5 10 2 3 2 5 2 2 4 9 19 39 自底向上： 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 4 4 4 4 4 4 4 4 3 8 8 8 8 7 16 16 32 39 See the code MergeSizes.java . 6. 访问数组的次数7. 比较次数单调递增8. 修改 -&gt; 有序数组线性级别\\(T(N) = 2T(N / 2) + 1\\) , 且 \\(T(1) = 0\\) 9. 辅助数组作为参数See the code Merge.java .","link":"/independent-pages/src/algs4/2/2.2/index.html"}],"posts":[{"title":"《算法（第4版）》知识点归纳解读 + 习题解析","text":"免责声明：本文部分内容来自于《 算法（第4版）》一书（中英），文中提供的所有资料仅供学习使用。如涉及到版权问题，请 邮箱 联系我。 本文主要记录自己在书中总结归纳的知识点以及一些易懂的解释，希望能帮助自己和大家更好地记忆书中的内容，并在复习时有一个可以对照的大纲。我在每个小节的后面也会附上习题的解答，可以作为参考。 （因为想要加快一下学习进度，顺便巩固所学知识，主要更新练习题，提高题和实验题后面会不定时更新） 部分解题代码用到了书中提供的类库，VS Code、 IDEA 等编辑器内置了快捷跳转至源码位置的操作，读者可以根据自身情况进行参考。另附本书配套的 在线 API 文档（非官方在线文档，支持搜索，托管于 GitHub）、部分章节源码 ，以及下载链接 API 文档 、algs4.jar 、algs4-data.zip 。 ‼️ 更新速度： 周一更新章节，周二更新习题，提高题和实验题会不定时更新。 预计完更时间：2020 年 2 月 部分习题答案是可以在 官网 上找到的。另外在 GitHub 上有人分享了自己的解题代码，虽然不是特别详细，但很值得参考，见 Algorithms 。 手头有书的同学最好与原书对照阅读，没有书的同学可以参考英文原版 Algorithms 4th.pdf 。 第 1 章&emsp;基 础&emsp;&emsp;1.1&emsp;基础编程模型&emsp;&emsp;1.2&emsp;数据抽象&emsp;&emsp;1.3&emsp;背包、队列和栈&emsp;&emsp;1.4&emsp;算法分析&emsp;&emsp;1.5&emsp;案例研究：union-find 算法 第 2 章&emsp;排 序&emsp;&emsp;2.1&emsp;初级排序算法&emsp;&emsp;2.2&emsp;归并排序&emsp;&emsp;2.3&emsp;快速排序&emsp;&emsp;2.4&emsp;优先队列&emsp;&emsp;2.5&emsp;应用 第 3 章&emsp;查 找&emsp;&emsp;3.1&emsp;符号表&emsp;&emsp;3.2&emsp;二叉查找树&emsp;&emsp;3.3&emsp;平衡查找树&emsp;&emsp;3.4&emsp;散列表&emsp;&emsp;3.5&emsp;应用 第 4 章&emsp;图&emsp;&emsp;4.1&emsp;无向图&emsp;&emsp;4.2&emsp;有向图&emsp;&emsp;4.3&emsp;最小生成树&emsp;&emsp;4.4&emsp;最短路径 第 5 章&emsp;排 序&emsp;&emsp;5.1&emsp;字符串排序&emsp;&emsp;5.2&emsp;单词查找树&emsp;&emsp;5.3&emsp;子字符串查找&emsp;&emsp;5.4&emsp;正则表达式&emsp;&emsp;5.5&emsp;数据压缩 第 6 章&emsp;背 景&emsp;&emsp;6.0&emsp;背景","link":"/algs4/"},{"title":"数据结构课程实践与收获","text":"大二上开设数据结构课程，教材为严蔚敏老师的 C 语言版，实验内容整体上就使用 C 语言来做了，其他语言也差不太多，大同小异，主要在于对数据结构的理解。这篇笔记用来记录课程实验的实践与收获。 Part 01&emsp;线性表 &emsp;&emsp;顺序表之初用 C 指针 &emsp;&emsp;循环链表解决约瑟夫环问题 - Golang 实现","link":"/data-struct-lessons/"},{"title":"同一客户端下使用多个 Git 账号","text":"我们在日常使用 Git 进行文件管理时，避免不了会使用多个账号的情况。自己在家开发一些小项目就托管在 Github 上面，而在公司的话会用到另外一个账号，可能是 GitLab 账号进行管理，或者是自己想要搭建一个个人博客并托管在另一个账号，那么单纯的 HTTPS 就不足以支持两个账号在同一客户端进行使用了，这时就需要用到 SSH 来进行管理。 PS: 这篇博客主要是想要记录自己多个 Git 账号的配置过程，以备查阅。 1. 清除 Git 的全局设置git config --global --unset user.namegit config --global --unset user.email 2. 生成新的 SSH keys用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pubssh-keygen -t rsa -C \"new email\" 在生成第一组 id_rsa 和 id_rsa.pub_ 可以选用默认的文件名，在出现提示输入文件名的时候要输入一个不同的文件名，比如： 这里填的是 id_rsa_new Enter file in which to save the key (~/.ssh/id_rsa): id_rsa_new 注： Windows 用户和 Mac 用户的区别就是，mac 中 .ssh 文件夹在根目录下，所以表示成 ~/.ssh/，而 Windows 用户是 C:\\Users\\Administrator\\.ssh。 执行 ssh-agent 让 ssh 识别新的私钥因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中： ssh-add ~/.ssh/id_rsa_new 如果出现 Could not open a connection to your authentication agent 的错误，就试着用以下命令： ssh-agent bashssh-add ~/.ssh/id_rsa_new ssh-add ~/.ssh/id_rsa_new 只能将把指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。 解决办法就是在添加 ssh 私钥的时候使用如下命令：ssh-add -K privateKey，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。 参考博客：http://www.icodeyou.com/2016/01/17/ssh-add-mac/ 3. 配置 ~/.ssh/config 文件# 该文件用于配置私钥对应的服务器Host git@github.com # 别名，随便定 后面配置地址有用 HostName https://github.com User git IdentityFile ~/.ssh/id_rsa # 密钥文件的地址，注意是私钥# second user(second@mail.com)Host git@code.xxxxxxx.com HostName https://code.xxxxxxx.com User git IdentityFile ~/.ssh/id_rsa_new PS: HostName 如果添加 https:// 前缀可能发生 public key 不能识别的情况，所以可以直接改为 github.com 4. 添加新的 SSH keys 到新账号的 SSH 设置中5. 测试一下$ ssh -T git@github.com # 此处是 Host 后面定义的别名Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.# 上面是 github 的成功返回语句，下面是 gitlab 的成功返回语句。$ ssh -T git@xxxxxx.comWelcome to GitLab, xxx! 链接：https://www.jianshu.com/p/89cb26e5c3e8/来源：简书 参考资料https://blog.csdn.net/onTheRoadToMine/article/details/79029331/ https://gist.github.com/suziewong/4378434/","link":"/git-one-more-account/"},{"title":"关于 VS Code 中 \"Classpath is incomplete\" warning","text":"本文翻译自官方 vscode-java Wiki 。 问题概述每当打开一个 java 文件时，它不属于项目（我们称之为独立的 java 文件），vscode-java 无法计算正确的类路径。它使报告编译错误变得毫无用处，因为 UI 会在整个文件中填充令人分心的红色错误，例如： 幸运的是，vscode-java 仍然能够为基本 JDK 类提供有用的内容辅助，报告语法错误，计算类大纲或允许代码导航。因此，显示以下警告： 如果您只是关闭消息，它将在下次打开独立的 java 文件时弹出。通过单击Don’t Show Again 选项，可以永久地丢弃该消息。 如果改变主意，可以在 VS Code 的用户设置中修改该选项：java.errors.incompleteClasspath.severity 键指定当 java 文件的类路径不完整时消息的严重性。支持的值包括 ignore, info, warning 和 error。 您需要打开一个包含 pom.xml, build.gradle 或至少是默认 eclipse 设置文件的文件夹，以便可以设置完整的类路径和项目层次结构。 Android 项目基于 Gradle 的 Android 项目目前显示此消息，因为目前不支持 Android 开发。这是 limitation of BuildShip，该项目提供 Gradle 支持。","link":"/vscode-warning-classpath-is-incomplete/"},{"title":"Mac 上好用的 APP 整理","text":"我整理了一些自己平常在 Mac 上经常用到的 APP，大家可以参考一下。另外我提供了项目网站和下载页面的地址。 文本编辑：Atom Atom 是由 GitHub 专门为程序员推出的跨平台文本编辑器，支持 CSS，HTML，JavaScript 等网页编程语言。 Emacs Emacs 是被公认为程序员最喜爱的代码编辑器之一，另外一个是 Vim。Emacs 使用 Emacs Lisp 这种极具扩展性的编程语言，实现了包括编程、编译乃至网络浏览等功能的扩展。 Sublime Text 3 Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 MacDown MacDown 是一款 Mac 下的 Markdown 编辑器。由于 Mou 的作者曾宣布不再继续该软件的开发并寻求出售所有权，所以 Macdown 的作者决定自己开发，MacDown 的很大一部分受到了 Mou 的影响。 效率工具：Alfred Alfred 是 Mac 下最流行的提升效率的工具。 AppCleaner AppCleaner 是 macOS 上的超轻量卸载专家。 Magnet Magnet 是 macOS 上进行窗口管理的快捷工具。 Pock Pock 是一款 macOS App，你可以通过它把 Touch Bar 变成系统中的 Dock 栏，直接用来切换和启动 App。 QSpace QSpace 是一款简洁高效的多视图文件管理器。 Sip Sip 是 macOS 上一款非常不错的取色软件。 清理工具：Tencent Lemon Tencent Lemon 是 macOS 上的一款清理软件，在 AppStore 上提供 Lite 版本的下载。 播放器：IINA IINA 是一个现代的 macOS 视频播放器。 通讯：Telegram Telegram 是一款跨平台的实时通讯软件。 云盘：Mega Mega 是一款云储存服务，免费版账户提供 35G 的云储存空间。 Seafile Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。普通用户提供 2GB 的储存空间。 VPN 服务Windscribe Windscribe 是一款跨平台的 VPN 服务，普通用户每月有 10GB 的免费流量。","link":"/awesome-mac-apps/"},{"title":"Hanoi 塔问题在 C++ 中的递归实现","text":"Hanoi 塔问题想必是很多同学在大一都会接触到的，它是一个很经典的算法问题，这里主要阐释 Hanoi 问题在 C++ 中的递归实现。当然你也可以查阅一些其他资料来理解它的非递归实现过程，这里就不再叙述了。有兴趣的同学可以参考：迭代式汉诺塔(利用栈实现非递归) &emsp; 汉诺塔问题的递归和非递归算法 本文意旨解决“为何圆盘的移动的位置不对？”的问题，用两组代码来分析圆盘的移动位置。 PS: 当然，如果想更好地理解这篇博客，就需要你在阅读之前对 Hanoi 塔问题有一个清晰的了解。如果你还不知道什么是 Hanoi 塔问题，请移步 百度百科。 开始分析1. 先来看一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 b 柱将圆盘全部移到 c 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucers: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 hanoi(n - 1, b, a, c); // 将第 n-1个圆盘从 b柱借助 a柱移动到 c柱} 如果你之前有成功实现过hanoi塔从 a 移动到 c (a ⟹ c) 的递归算法，应该很容易就能看懂。但是你试过将圆盘从 a 柱全部移动到 b 柱上的情况吗？ 如果你已经清楚了代码的含义，那么你可以试着实现另外的几种情况 a ⟹ b b ⟹ c c ⟹ a c ⟹ b 2. 再来看另一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 c 柱将圆盘全部移到 b 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucer: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 hanoi(n - 1, c, b, a); // 将第 n-1个圆盘从 c柱经由 a柱移动到 b柱} 你可能会觉得两组代码在实现上没什么差别，那我们来看两组代码其中一行的对照： hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 我们可以发现，两组代码中这一行代码都是相同的，但为什么实现的操作是不一样的呢？ 3. 其中两行代码的对比std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 我们可以看到第一行代码时从 a位置 指向 c位置，第二行代码则是从 a位置 指向 b位置， 而第一行代码中的 “a位置” 和 “c位置” 对应了第一组代码 hanoi(n - 1, a, c, b); 中的 c 和 b，第二行代码中的 “a位置” 和 “b位置”对应了第二组代码 hanoi(n - 1, a, c, b); 中的 c 和 b 整组代码中实现输出是依靠 输出流语句，所以 hanoi(n - 1, a, c, b); 中的字母顺序要根据 输出流语句 的变化而变化以达到正确调用递归的目的。 也是大一刚开始接触编程语言，希望我的分享能给大家带来帮助 (｡･∀･)ﾉﾞ 到这里如果你还没有弄明白，这里能以图的形式更直观地理解 Hanoi 塔问题的递归实现，请参考：汉诺塔的图解递归算法","link":"/hanoi-cpp/"},{"title":"Web 开发学习规划","text":"决定走 Web 开发方向，需要自己规划一个学习路线，文中还会包括一些公司对于应届生的技术要求。 一些招聘要求工作职责 根据 UI 图和交互设计稿完成移动端开发工作； 研究并改善产品，优化用户体验，兼容各类浏览器及性能优化； HTML5、CSS3 移动端新技术的研究及应用； 负责或协助相关开发文档的撰写； 根据产品需求，分析并给出合理的页面前端结构解决方案； 负责前端框架设计、前端开发工作统筹； 与产品、后端沟通，协同进行前后端分离的开发模式； … 技术要求 熟知 W3C 标准，精通 HTML、CSS、JavaScript 等 Web 前端开发技术，熟悉前端开发流程； 熟悉 Vue、React、Angular 等 MVVM 前端开发框架语法和编程思想； 有实际的 Vue / React / 小程序 等项目开发经验； 熟悉 TypeScript, 了解 Express / Koa 等中间层框架； 熟悉 Node.js ，有开发经验，并有实际产出； 熟练掌握工程化工具的使用，如 Webpack、Gulp 等，并对其原理有所了解，有相关实践经历者优先； 熟练运用 Sass、Less、Stylus 等任意一种预编译工具； 熟练掌握 Git 等版本管理工具的使用； … 加分项 有前端架构经验； 熟练使用图片处理工具如：PS 等，会设计优先考虑； 有技术博客或 GitHub 账号并持续更新； 有编写过开源项目，提供 GitHub 地址优先； 对于不同浏览器的兼容以及移动端兼容有自己的见解； … Web 开发学习路线2019 年成为 Web 开发人员的路线图 介绍 前端路线图 后端路线图 运维路线图 图片来源：goodjack 的译版 developer-roadmap-chinese，译自 developer-roadmap 。 另外可以参考对 developer-roadmap 的 部分解读 。 学习路线规划与选择 前端 Front-end Part 01&emsp;Basics &ensp;HTML &ensp;CSS &ensp;JavaScript 关于 Web 前端怎样入门可以参考 知乎问答 ，指南与资料见 思否 （2016 年底更新）。准备 2019-2020 上学期进行此部分的学习，兼顾算法与数据结构。目前参加了中国大学 MOOC 上北京林业大学开设的课程 Web 前端开发 。 — 2019.09 Part 02&emsp;Package Managers &ensp;NPM &ensp;Yarn 此部分与网站构建关系不是很大，现在就开始学习。 — 2019.09 Part 03&emsp;CSS Pre-processors（CSS 预处理器） &ensp;Sass Part 04&emsp;CSS Frameworks（CSS 框架） &ensp;BootScrap Part 05&emsp;CSS Architecture（CSS 架构规范） &ensp;BEM Part 06&emsp;Build Tools（构建工具） Linters and Formatters &ensp;ESLint &ensp;Prettier Task Runners &ensp;NPM Scripts Module Bundlers（模组打包工具） &ensp;Webpack Part 07&emsp;Pick a Framework&emsp;&emsp;&emsp;&ensp;What is SPA ? &ensp;Vue.js &ensp;Vuex Part 08&emsp;CSS in JS * &ensp;Styled Componments &ensp;CSS Modules Part 09&emsp;Testing Apps &ensp;Jest &ensp;Cypress Part 10&emsp;Progressive Web Apps（渐进式网页应用程序）* &ensp;Storage &ensp;Web Sockets &ensp;Service Workers Part 11&emsp;TypeCheckers &ensp;TypeScript Part 12&emsp;Server Side Rendering（伺服务端渲染）* &ensp;Nuxt.js Part 13&emsp;Static Site Generators（静态网站生成器）* &ensp;Gatsby.js Part 14&emsp;Desktop Applications * &ensp;Electron Part 15&emsp;Mobile Applications * &ensp;NativeScript Part 16&emsp;Web Assembly * 后端 Back-end Part 01&emsp;Pick a Language &ensp;Java &ensp;Node.js &ensp;Go Part 02&ensp;PracticePart 03&ensp;Package Manager &ensp;NPM &ensp;Yarn Part 04&ensp;Standard and Best PracticesPart 05&ensp;Make and Distribute Some Package/Library &ensp;Contribute to Some Opensource Projects Part 06&ensp;Learn about Testing &ensp;Unit tests &ensp;Integration tests Part 07&emsp;Write Tests for the practical steps above（为实际步骤撰写测试）Part 08&emsp;Learn Relational Datebase &ensp;MySQL Part 09&emsp;Practical TimePart 10&emsp;Learn a FrameworkPart 11&emsp;Practical TimePart 12&emsp;Learn a NoSQLPart 13&emsp;CachingPart 14&emsp;Creating RESTful APIsPart 15&emsp;Authentication/Authorization MethodologiesPart 16&emsp;Message BrokersPart 17&emsp;Learn a Search Engine &ensp; Part 18&emsp;Learn How to Use DockerPart 19&emsp;Knowledge of Web ServersPart 20&emsp;Learn How to Use Web SocketsPart 21&emsp;Learn GraphQLPart 22&emsp;Look into Graph DatebasePart 23&emsp;All the things that weren’t mentioned above &ensp;Profiling（效能分析） &ensp;Static Analysis（静能分析） &ensp;DDD（领域驱动设计） &ensp;SOAP（简单物件存取协定） 参考文档前端框架 Vue.js React.js Angular.js 中间层框架 Express Koa 其他框架 BootScrap 工程化工具 Webpack Gulp 预编译工具 Sass Less Stylus Package Manager NPM Yarn 类型检查工具 TypeScript 版本控制 Git","link":"/web-index/"},{"title":"Web 学习笔记","text":"HTML5 基础","link":"/web-note/"},{"title":"C++ Primer 手记","text":"免责声明：本文摘自 《 C++ Primer 中文版 》，所有内容仅供学习使用。如涉及到版权问题，请 邮箱 联系我。 本文用来记录书中的一些重要知识点，来帮助自己和大家更好地回忆书中内容。 第 I 部分&emsp;C++ 基础&emsp;&emsp;02&emsp;变量和基本类型&emsp;&emsp;03&emsp;字符串、向量和数组&emsp;&emsp;04&emsp;表达式&emsp;&emsp;05&emsp;语句&emsp;&emsp;06&emsp;函数&emsp;&emsp;07&emsp;类 第 II 部分&emsp;C++ 标准库&emsp;&emsp;08&emsp;IO 库&emsp;&emsp;09&emsp;顺序容器&emsp;&emsp;10&emsp;泛型算法&emsp;&emsp;11&emsp;关联容器&emsp;&emsp;12&emsp;动态内存 第 III 部分&emsp;类设计者的工具&emsp;&emsp;13&emsp;拷贝控制&emsp;&emsp;14&emsp;重载运算符与类型转换&emsp;&emsp;15&emsp;面向对象程序设计&emsp;&emsp;16&emsp;模版与范型编程 第 IV 部分&emsp;高级主题&emsp;&emsp;17&emsp;标准库特殊设施&emsp;&emsp;18&emsp;用于大型程序的工具&emsp;&emsp;19&emsp;特殊工具与技术","link":"/cpp-primer-note/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hanoi","slug":"Hanoi","link":"/tags/Hanoi/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/笔记/"},{"name":"开发工具","slug":"开发工具","link":"/categories/开发工具/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"算法","slug":"C/算法","link":"/categories/C/算法/"}]}