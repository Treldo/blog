{"pages":[{"title":"","text":"个人介绍 本科在读 喜欢写一些归纳类的文章 联系方式 邮箱：vuebee@163.com","link":"/about/index.html"},{"title":"基础编程模型","text":"1. 原始数据类型与表达式原始数据类型 &ensp;8 位整数，byte 16 位整数，short 32 位整数，int 64 位整数，long 16 位字符，char 32 位单精度实数，float 64 位双精度实数，double 表达式 Java 中使用 中缀 表达式，即：运算符在字面量或表达式之间。 逻辑运算符中 ! 拥有最高优先级，之后是 &amp;&amp;，然后是 ||。 2. 语句 声明语句：Java 是强类型语言，编译器会检查类型的一致性。 赋值语句：左侧必须是单个变量，右侧是能够得到相应类型的任意表达式。 条件语句：不同操作来处理不同的输入，分为 if 语句和 switch 语句。 循环语句：主要是 while 语句和 for 语句，循环语句中的代码称为循环体。 调用和返回语句：与静态方法有关，是执行流程和代码组织的另一种方式。 其他语句 break 语句：退出循环。 continue 语句：立即开始下一轮循环。 return 语句：返回值。 3. 数组 对于数组 a[]，程序可以通过 a.length() 获取数组长度。 可能出现的异常 ArrayIndexOutOfBoundsException 数组别名当我们将一个数组变量赋给另一个变量，那么两个变量都会指向同一个数组。 int[] a = new int[N];a[i] = 123;int[] b = a;b[i] = 456;System.out.print(a[i]); // 此处输出 a[i] 的值为 456 4. 静态方法静态方法是一组在被调用时会被顺序执行的语句，拥有修饰符 static，区别于实例方法。 方法的性质 方法的参数按值传递：方法中使用的参数变量可以引用调用者的数组并改变其内容，但不能改变与原数组变量本身（值传递）。也就是在方法中改变一个参数变量的值对调用者本身没有影响。 方法名可以被重载：例如同名方法可以传入多种参数类型。 方法只能返回一个值，但可以包含多个返回语句：返回被执行语句中第一条返回语句的参数。 方法可以产生副作用：void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或改变系统状态）。 递归方法可以调用自己；递归代码比相应的非递归代码更加简洁优雅、易懂。 最简单的情况：方法的第一条语句总是一个包含 return 的条件语句。 递归的调用总是去尝试解决规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。 // 二分查找的递归实现public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1);}public static int rank(int key, int[] a, int lo, int hi) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; }} 基础编程模型Java 开发的基本模是编写一个静态方法库（包含一个 main() 方法）来完成一个任务。 模块化编程我们可以构造许多个静态方法库（模块），一个库中的静态方法也可以调用另一个库中定义的静态方法。这能够带来很多好处： 程序整体的代码量很大时，每次处理的模块大小仍然适中； 可以共享和重用代码而无需重新实现； 很容易用改进的实现替换旧的实现； 可以为解决编程问题建立合适的抽象模型； 缩小测试范围。 单元测试每一个静态方法库中都包含一个 main() 函数来测试库中的所有方法（有些编程语言不支持多个 main() 方法，所以不支持这种方式）。我们可以将 main() 方法作为一个开发用例，在开发过程中用它来测试更多的细节；也可以将它编写成一个测试用例来对所有代码进行一个全面的测试。当用例越来越复杂，我们可能会将它独立成一个模块。 外部库 系统标准库 java.lang.*：包括实现了常用数学函数的 Math 库以及其他。 导入的系统库，例如 java.util.Arrays：需要在程序的开头使用 import 语句导入。 5. API模块化编程的一个重要组成部分就是记录库方法的用法并提供其他人参考的文档；我们应该将自己编写的每一个程序都当作一个日后可以重用的库。关于 API 的说明可参考 什么是 API ？ 6. 输入输出重定向与管道重定向将程序的输出重定向至一个文件： % java RandomSeq 1000 100.0 200.0 &gt; data.txt 重定向标准输入使从文件中读取数据： % java Average &lt; data.txt 管道将一个程序的输出重定向为另一个程序的输入叫做管道： % java RandomSeq 1000 100.0 200.0 | java Average 突破了能够处理的输入输出流的限制 运行的先后顺序由操作系统决定 7. 白名单过滤信用卡公司的例子： 将客户账号保存在一个文件中，称为白名单； 从标准输入中得到每笔交易的账号； 使用测试用例在标准输出中打印所有与客户无关的账号，公司很可能拒绝此类交易。 % java BinarySearch tinyW.txt &lt; tinyT.txt 此处的 tinyW.txt 就是一个白名单。 知识点+ Java 中一个静态方法不能作为另一个静态方法的参数，但在一些其他语言中可以。 习题见 习题 1-1","link":"/independent-pages/list/algs4/1/1.1/index.html"},{"title":"习题 1-1","text":"知乎上有一篇总结的还不错, 如果觉得不够详细，或者想要参考题目以及其他答案的同学，可以在 这里 找到。 练习1. 表达式的值&emsp;a. 7&emsp;b. 200.0000002&emsp;c. true 2. 类型和值&emsp;a. double, 1.618&emsp;b. double, 10.0&emsp;c. boolean, true&emsp;d. String, 33 3. equal 判断import java.util.Scanner;public class Test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); if (a == b &amp;&amp; b == c) { System.out.println(\"equal\"); } else { System.out.println(\"not equal\"); } }} 4. 语句修正if (a &gt; b) c = 0; else b = 0; 5. 范围判断import java.util.Scanner;public class Test { public static boolean right(double d) { if (d &gt;= 0.0 &amp;&amp; d &lt;= 1.0) { return true; } else { return false; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); double x = sc.nextDouble(); double y = sc.nextDouble(); if (right(x) &amp;&amp; right(y)) { System.out.println(\"true\"); } else { System.out.println(\"false\"); } }} 6. Fibnonacci 数列// 斐波那契数列的非递归算法int f = 0;int g = 1;for (int i = 0; i &lt;= 15; i++) { System.out.println(f); f = f + g; g = f - g;} 结果01123581321345589144233377610 7. 打印的值&emsp;a. 3.00009&emsp;b. 499500&emsp;c. 10000 8. 打印结果&emsp;a. b&emsp;b. 197&emsp;c. e 9. 正整数二进制 Java 中有内置方法 Integer.toBinaryString(); // 一个简洁的实现方法String s = \"\";for (int n = N; n &gt; 0; n /= 2) { s = (n % 2) + s;} 10. 代码存在的问题没有用 new 为 a[] 分配内存，会产生一个 variable a might not have been initialized 的编译错误。 int[] a;for (int i = 0; i &lt; 10; i++) { a[i] = i * i;} 11. 打印二维布尔数组// 已初始化 boolean 类型二维数组 bfor (boolean[] booleans : b) { System.out.print(lineNumber++ + \"| \"); for (boolean aBoolean : booleans) { if (aBoolean) { System.out.print(\"*\"); } else { System.out.print(\" \"); } } System.out.println();} 12. 打印结果此处书中有误，代码段应为： int[] a = new int[10];for (int i = 0; i &lt; 10; i++) a[i] = 9 - i;for (int i = 0; i &lt; 10; i++) a[i] = a[a[i]];for (int i = 0; i &lt; 10; i++) System.out.println(i); 结果0123443210 13. 二维数组的转置// 使用 int 类型数组举例，已初始化数组 a[M][N]int[][] temp = new int[N][M];for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][j] = a[j][i]; System.out.print(temp[i][j] + \" \"); } System.out.println();} 14. 返回不大于 log₂N 的最大整数public static int lg(int N) { int result = 0; int temp = 2; while (temp &lt; N) { temp *= 2; result++; } return result;} 15. 返回长度为 M 的数组public static int[] histogram(int[] a, int M) { int[] temp = new int[M]; for (int i = 0; i &lt; M; i++) { for (int value : a) { if (i == value) temp[i]++; } } return temp;} 16. exR1(6) 的返回值311361142246 17. 递归函数的问题这段代码中的基础情况永远不会被访问。调用 exR2(3) 会产生调用 exR2(0)、exR2(-3) 和 exR2(-6)，循环往复直到发生 StackOverflowError。 18. 考察乘法与乘方的递归实现 修改前： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a + a, b / 2); return mystery(a + a, b / 2) + a;} 返回值 mystery(2, 25) = 50mystery(3, 11) = 33mystery(a, b) = a * b 核心思想： x * y = (x * 2 * 2 * ...) * (y / 2 / 2 / ...)PS: 此处的 x 可能为偶数，但 y 必为奇数。 修改后： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a * a, b / 2); return mystery(a * a, b / 2) * a;} 返回值 mystery(2, 25) = 33554432mystery(3, 11) = 177147mystery(a, b) = aᵇ 核心思想： x ^ y = (x ^ 2) ^ (y / 2) 19. 改进 F(N) 的实现书上的递归方法探究一小时之内能够得到 F(N) 结果最大的 N 值因为耗时比较长这里就不做尝试了。改进的方法可以参考 6 中的 斐波那契数列的非递归算法 ，下面的是按书上要求利用数组保存值的改进方法： public static long F(int N) { int[] a = new int[N]; a[0] = 0; a[1] = 1; for (int i = 2; i &lt; N; i++) { a[i] = a[i - 1] + a[i - 2]; } return a[N - 1];} 20. ln(N!) 的递归求解public static double ln(int N) { if (N == 0 || N == 1) { return; } else { return ln(N - 1) + Math.log(N); }} 21. 输入数据打印表格这里用到了 printf() 的格式化输出，不懂的同学请自行参考 菜鸟教程 。 System.out.print(\"Please input data count: \");Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();String[] nameArray = new String[n];int[] integerArray1 = new int[n];int[] integerArray2 = new int[n];for (int i = 0; i &lt; n; i++) { nameArray[i] = scanner.next(); integerArray1[i] = scanner.nextInt(); integerArray2[i] = scanner.nextInt();}System.out.println(\"|----------|-----|-----|-----|\");for (int i = 0; i &lt; n; i++) { System.out.printf(\"|%-10s|%-5d|%-5d|%.3f|\\n\", nameArray[i], integerArray1[i], integerArray2[i], ((double) integerArray1[i] / integerArray2[i])); System.out.println(\"|----------|-----|-----|-----|\");} 看到有一个比较有意思的解题方法，思路是用 split() 方法将得到的两行数据进行拆分。缺点是如果输入的数据不是以单个空格为间隔就会报 NumberFormatException 的异常。 Scanner sc = new Scanner(System.in);String[] a = new String[2];int index = 0;while (index &lt; a.length) { a[index] = sc.nextLine(); index++;}for (String s : a) { String[] stringArr = s.split(\" \"); int num1 = Integer.parseInt(stringArr[1]); int num2 = Integer.parseInt(stringArr[2]); System.out.printf(\"%-10s%-5d%-5d%.3f\\n\", stringArr[0], num1, num2, ((double) num1 / num2));} 22. BinarySearch-按递归深度缩进如果你忘记了之前的 rank() 方法，可以在 这里 找到它。下面来对它进行改写： public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1, 1);}// 如果是在某一限定范围内进行查找，则需要手动传入参数 `deep` 的值// `deep` 的值需要设定在大于等于 1 的整数群中，否则在第 3 - deep 行中才会出现缩进效果public static int rank(int key, int[] a, int lo, int hi, int deep) { // 实现缩进 for (int i = 1; i &lt; deep; i++) { System.out.print(\" \"); } System.out.printf(\"%d. lo: %d hi: %d\\n\", deep, lo, hi); // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1, deep + 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi, deep + 1); } else { return mid; }} 23. BinarySearch 的测试用例public static void main(String[] args) { int[] whiteList = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.print(\"Please input \\\"+\\\" or \\\"-\\\": \"); // 为避免读入多余字符使用了 edu.princeton.cs.algs4 包中 StdIn 类里的 readChar() 方法 char flag = StdIn.readChar(); // 读入第一个字符以外的其余字符（不作用途） StdIn.readLine(); System.out.print(\"Please input keys(Split with space): \"); String[] keyList = StdIn.readLine().split(\" \"); for (String s : keyList) { if (flag == '+') { if (rank(Integer.parseInt(s), whiteList) == -1) { System.out.printf(\"%s \", s); } } else if (flag == '-') { if (rank(Integer.parseInt(s), whiteList) != -1) { System.out.printf(\"%s \", s); } } } System.out.println(\"\\nDone!\");} 24. 欧几里得算法计算最大公约数public class Euclid { public static int euclid(int p, int q) { if (q == 0) { return p; } System.out.printf(\"p = %d, q = %d\\n\", p, q); // 交换值的目的是为了减小递归的运算次数 if (p &lt; q) { int temp = p; p = q; q = temp; } return euclid(q, p % q); } public static void main(String[] args) { int p = StdIn.readInt(); int q = StdIn.readInt(); System.out.println(\"\\nresult = \" + euclid(p, q)); }} 25. 数学归纳法证明欧几里得算法参考：&emsp;简书 - 欧几里得算法心得(辗转相除法)&emsp;百度文库 - 辗转相除法的证明","link":"/independent-pages/src/algs4/1/1.1/index.html"},{"title":"数据抽象","text":"抽象数据类型 （ADT） 是一种能够对使用者隐藏数据表示的数据类型。使用抽象数据类型时，我们的注意力集中在 API 描述的操作上而不会去关心数据的表示；实现抽象数据类型时，我们的注意力集中在数据本身并将实现对该数据的各种操作。 以适用于各种用途的 API 形式准确地定义问题； 用 API 的实现描述算法和数据结构。 特点：可以在不修改任何用例代码的情况下使用一种算法替换另一种算法并改进所有用例的性能。 1. 使用抽象数据类型抽象数据类型的 API抽象数据类型的定义和静态方法库之间的共同点： 两者的实现均为 Java 类； 实例方法可以接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔； 可能返回指定类型的值。 不同点： API 中会出现名称和类名相同的没有返回值的构造函数； 实例方法不需要 static 关键字，目的是操作数据类型中的值； 尊重 Java 习惯而存在的继承方法，在 API 中显示为灰色。 继承的方法大致有 toString() 、equals() 、compareTo() 、hashCode()。在使用 “+” 运算符将任意数据类型的值和 String 值连接时会调用 toString() 方法。 对象对象的创建与使用调用 new() 时，系统会： 为新的对象分配内存空间； 调用构造函数初始化对象中的值； 返回该对象中的一个引用。 静态方法的主要作用是实现函数；非静态（实例）方法的主要作用是实现数据类型的操作。一个开头是类名，一个开头是对象名。 开发某种给定数据类型的用例： 声明该类型变量，以用来引用对象； 使用关键字 new 触发能够创建该类型的对象的一个构造函数； 使用变量名在语句或表达式中调用实例方法。 使用与对象关联的变量： 赋值语句； 向方法传递对象或是从方法中返回对象； 创建并使用对象的数组。 赋值语句 不会创建对象，而是创建另一个指向某个已经存在的对象的引用。这种情况称为 别名 ：两个变量同时指向同一个对象。 对于原始数据类型的变量，会发生值的复制。而对于引用类型，复制的是引用而非实际的值。例如： int a = 0;int b = a;b++;System.out.println(a);System.out.println(b); 此时输出的 a 的值为 0，b 的值为 1。再试着运行下面的程序： public class Test { public static void main(String[] args) { Num num = new Num(4); Num num2 = num; num2.add(2); System.out.println(num.getValue()); }}class Num { private int value; Num(int value) { this.value = value; } int getValue() { return value; } void add(int increment) { value += increment; }} 这是将对象作为参数的情况。我们可以发现 num.value 的值随着 num2 对 add() 方法的调用改变了。 PS: 方法无法改变原始的引用，但能够改变对象的值。 Java 中的方法只能有一个返回值，如果使用对象的话，实际上就能够返回多个值。 数组与对象Java 中所有非原始数据类型的值都是对象。这样一来，数组也是对象。 创建一个对象数组： 使用方括号语法调用数组的构造函数创建数组； 对于每个数组元素，调用它的构造函数创建相应的对象。 Java 中的对象数组实际上是一个由对象的引用组成的数组。如果对象非常大，在移动对象时只需要移动对象的引用，这样大大提高了效率；而对象非常小的时候，每次获取信息都需要通过引用来操作反而降低了效率。 对象的三大关键性质：状态、标识和行为。 一个数据类型的实现所支持的操作： 创建对象（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的值并返回它的引用。 操作对象中的值（控制对象的行为，可能会改变对象的状态）：使用对象关联的变量调用实例方法来对对象中的值进行操作。 操作多个对象：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身。 2. 抽象数据类型举例几何对象信息处理字符串String a = \"now is \";String b = \"the time \";String c = \"to\"; 方法 返回值 a.length() 7 a.charAt(4) i a.concat(c) “now is to” a.indexOf(&quot;is&quot;) “w i” a.substring(2, 5) “now” a.split(&quot; &quot;)[0] “now” a.split(&quot; &quot;)[1] “is” b.equals(c) false 3. 抽象数据类型的实现 实例变量：每个实例变量的声明都需要一个 可见性修饰符。 构造函数 实例方法 作用域 API、用例与实现 实例变量如果使用 public 修饰的话，根据定义，这种数据类型就不是抽象的了。所以一般不会这么做。 构造函数 类似于静态方法，能够直接访问变量并且没有返回值； 每一个构造函数都会创建一个对象并向调用者返回一个该对象的引用； 名称与类型相同； 支持重载； 如果没有构造函数，将会隐式定义 0，false，null 的默认值（前提是参数没有提供默认值）。 实例方法同静态方法大都是语法上的区别。 作用域 参数变量：整个方法。 局部变量：当前代码段中定义之后的所有语句。 实例变量：整个类。 如果实例变量出现二义性，可以使用 this 进行区别。 4. 更多抽象数据类型的实现维护多个实现 通过前缀描述性修饰符进行区别； 维护一个没有前缀的参考实现以适用大多数用例的需求。 累加器维护一个 int 类型的实例变量来记录已经处理过的数据值的数量，以及一个 double 类型的实例变量来记录所有数据之和，除以数据数量得到平均值。 实现 public class Accumulator { private double total; private int N; public void addDateValue(double val) { N++; total += val; } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestAccumulator { public static void main(String[] args) { // 如果不想使用终端输入命令的方式，此处也可以改为 // int T = StdIn.readInt(); // 如此就可以在输入端输入 T 值 int T = Integer.parseInt(args[0]); Accumulator a = new Accumulator(); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法 % java TestAccumulator 1000Mean (1000 values): 0.51829 可视化的累加器使用 StdDraw 画出所有数据（灰色）和实时平均值（红色）。 实现 public class VisualAccumulator { private double total; private int N; public VisualAccumulator(int trials, double max) { StdDraw.setXscale(0, trials); StdDraw.setYscale(0, max); StdDraw.setPenRadius(.005); } // 副作用：实现绘图 public void addDateValue(double val) { N++; total += val; StdDraw.setPenColor(StdDraw.DARK_GRAY); StdDraw.point(N, val); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(N, total / N); } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestVisualAccumulator { public static void main(String[] args) { int T = Integer.parseInt(args[0]); VisualAccumulator a = new VisualAccumulator(T, 1.0); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法与 Accumulator 用法一致。 5. 数据类型的设计 省略，待更新 知识点+ 原始数据类型更接近计算机硬件所支持的数据类型，使用起来要要快于引用类型。 有时候会用私有实例方法在公有方法之间共享代码。 没有使用 new 关键字创建对象得到的 错误 与引用一个未定义符号相同，构造函数的参数数量不对也会出现相同的错误信息。 创建对象数组每一个对象都需要使用 new 关键字：没有创建数组与为一个未初始化的变量赋值得到的 错误 相同。如果尝试调用未初始化对象的方法，会得到 空指针异常 。 println() 接受一个 Object 对象。 指针是什么？ 实现引用的一种自然方式是使用指针（机器地址），另一种可能是句柄（指针的指针）。前者访问数据的速度很快，后者能够更好地实现垃圾回收。 继承的问题：子类代码可以访问所有实例变量，因此可以改变值。 类中的所有方法都可以访问静态变量。静态变量的作用域是全局的，所以使用时要非常小心。 不再被支持但为了保持兼容性而留在 API 中的方法叫做被弃用（deprecated）的方法。 习题见 习题 1-2","link":"/independent-pages/list/algs4/1/1.2/index.html"}],"posts":[{"title":"《算法（第4版）》知识点归纳","text":"这篇博客主要来记录自己在书中总结归纳的知识点，来帮助自己更好地记忆书中的内容，并在复习时有一个可以参考的大纲。我在每个小节的后面也有附上习题的解答（因为想要加快一下学习进度，所以目前只提供练习题的解题步骤，后期会对提高题以及实验题进行补充）。部分解题代码用到了书中提供的类库，VS Code、 IDEA 等编辑器或编译器内置了快捷跳转至源码位置的操作，读者可以根据自身情况进行参考。另附本书配套的 在线 API 文档 、源码 ，以及下载链接 algs4.jar 、algs4-data.zip 。 部分习题答案是可以在 官网 上找到的。另外在 GitHub 上有一个分享自己解题代码的仓库，很详细，值得参考，见 Algorithms 。 PS: 本文中的大部分内容来自于《算法（第4版）》一书，想要了解的同学可以参阅 豆瓣读书 ，另见 英文版 。 第 1 章&emsp;基 础&emsp;&emsp;1.1&emsp;基础编程模型&emsp;&emsp;1.2&emsp;数据抽象&emsp;&emsp;1.3&emsp;背包、队列和栈&emsp;&emsp;1.4&emsp;算法分析&emsp;&emsp;1.5&emsp;案例研究：union-find 算法 第 2 章&emsp;排 序&emsp;&emsp;2.1&emsp;初级排序算法&emsp;&emsp;2.2&emsp;归并排序&emsp;&emsp;2.3&emsp;快速排序&emsp;&emsp;2.4&emsp;优先队列&emsp;&emsp;2.5&emsp;应用 第 3 章&emsp;查 找&emsp;&emsp;3.1&emsp;符号表&emsp;&emsp;3.2&emsp;二叉查找树&emsp;&emsp;3.3&emsp;平衡查找树&emsp;&emsp;3.4&emsp;散列表&emsp;&emsp;3.5&emsp;应用 第 4 章&emsp;图&emsp;&emsp;4.1&emsp;无向图&emsp;&emsp;4.2&emsp;有向图&emsp;&emsp;4.3&emsp;最小生成树&emsp;&emsp;4.4&emsp;最短路径 第 5 章&emsp;排 序&emsp;&emsp;5.1&emsp;字符串排序&emsp;&emsp;5.2&emsp;单词查找树&emsp;&emsp;5.3&emsp;子字符串查找&emsp;&emsp;5.4&emsp;正则表达式&emsp;&emsp;5.5&emsp;数据压缩 第 6 章&emsp;背 景&emsp;&emsp;6.0&emsp;背景","link":"/algs4/"},{"title":"Hanoi 塔问题在 C++ 中的递归实现","text":"Hanoi 塔问题想必是很多同学在大一都会接触到的，它是一个很经典的算法问题，这里主要阐释 Hanoi 问题在 C++ 中的递归实现。当然你也可以查阅一些其他资料来理解它的非递归实现过程，这里就不再叙述了。有兴趣的同学可以参考：迭代式汉诺塔(利用栈实现非递归) &emsp; 汉诺塔问题的递归和非递归算法 本文意旨解决“为何圆盘的移动的位置不对？”的问题，用两组代码来分析圆盘的移动位置。 PS: 当然，如果想更好地理解这篇博客，就需要你在阅读之前对 Hanoi 塔问题有一个清晰的了解。如果你还不知道什么是 Hanoi 塔问题，请移步 百度百科。 开始分析1. 先来看一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 b 柱将圆盘全部移到 c 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucers: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 hanoi(n - 1, b, a, c); // 将第 n-1个圆盘从 b柱借助 a柱移动到 c柱} 如果你之前有成功实现过hanoi塔从 a 移动到 c (a ⟹ c) 的递归算法，应该很容易就能看懂。但是你试过将圆盘从 a 柱全部移动到 b 柱上的情况吗？ 如果你已经清楚了代码的含义，那么你可以试着实现另外的几种情况 a ⟹ b b ⟹ c c ⟹ a c ⟹ b 2. 再来看另一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 c 柱将圆盘全部移到 b 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucer: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 hanoi(n - 1, c, b, a); // 将第 n-1个圆盘从 c柱经由 a柱移动到 b柱} 你可能会觉得两组代码在实现上没什么差别，那我们来看两组代码其中一行的对照： hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 我们可以发现，两组代码中这一行代码都是相同的，但为什么实现的操作是不一样的呢？ 3. 其中两行代码的对比std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 我们可以看到第一行代码时从 a位置 指向 c位置，第二行代码则是从 a位置 指向 b位置， 而第一行代码中的 “a位置” 和 “c位置” 对应了第一组代码 hanoi(n - 1, a, c, b); 中的 c 和 b，第二行代码中的 “a位置” 和 “b位置”对应了第二组代码 hanoi(n - 1, a, c, b); 中的 c 和 b 整组代码中实现输出是依靠 输出流语句，所以 hanoi(n - 1, a, c, b); 中的字母顺序要根据 输出流语句 的变化而变化以达到正确调用递归的目的。 也是大一刚开始接触编程语言，希望我的分享能给大家带来帮助 (｡･∀･)ﾉﾞ 到这里如果你还没有弄明白，这里能以图的形式更直观地理解 Hanoi 塔问题的递归实现，请参考：汉诺塔的图解递归算法","link":"/hanoi-cpp/"},{"title":"Emacs Note","text":"这是一个 Emacs 的学习笔记，用来记录一些重要的知识点，以便于帮助自己进行回顾。笔记的大部分内容来自于 Spacemacs Rocks 第二季 的课程。 参见：&emsp; &emsp; 子龙山人：Master Emacs in 21 Days&emsp; &emsp; 视频教程：优酷 &emsp; 百度网盘 &emsp; YouTube 在 Emacs 中使用 C-h t 打开 Emacs Tutorial ，完成官方教程 1. 基础操作常见的符号意义： C(trl) 在 Mac 上为 Control 键 M(eta) 在 Mac 上为 Option 键 s(uper) 在 Mac 上为 Command 键 S(hift) 光标的移动： C-f 为前移一个字符， f 代表 forward C-p 为上移至前一行， p 代表 previous C-n 为上移至下一行， n 代表 next C-a 为移至行首， a 代表 ahead C-e 为移至行尾， e 代表 end 常用的文件操作： C-x C-f 为打开目标文件 f 代表 find / file C-x C-s 为保存当前缓冲区（Buffer）， s 代表 save C-x C-e 快捷键就是按预先绑定好的方式执行命令相似的前缀命令还有 C-c、C-h 2. 内置功能 M-x linum-mode 开启编辑器内的行号显示 3. 学习 Elisp 基础阅读教程 Learn X in Y minutes ，或参见 中文版 ;; 2 + 3 * 4(+ 2 (* 3 4))(setq my-name \"Mark\")(message my-name)(defun my-func () ;; Specify a way of parsing arguments for interactive use of a function. (interactive) (message \"Hello, %s\" my-name))(global-set-key (kbd \"&lt;f2&gt;\") 'my-func) 4. 简单的编辑器自定义Emacs 的配置文件默认保存在 ~/.emacs.d/init.el 文件中，也可以保存在 ~/.emacs 文件中。 如果将配置放在 ~/.emacs.d/init.el 文件中，需要手动删除 ~/.emacs 文件。 ;; 关闭工具栏，tool-bar-mode 是一个 Minor Mode(tool-bar-mode -1);; 关闭文件滑动控件(scroll-bar-mode -1);; 显示行号(global-linum-mode 1);; 更改光标的样式(golbal-setq cursor-type 'bar);; 关闭启动帮助画面(setq inhibit-splash-screen 1);; 关闭缩进;; (electric-indent-mode -1);; 更改显示字体大小 16pt;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs(set-face-attribute 'default nil :height 160);; 快速打开配置文件(defun open-init-file() (interactive) (find-file \"~/.emacs.d/init.el\"));; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上(global-set-key (kbd \"&lt;f2&gt;\") 'open-init-file) 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加载配置文件。重新加载配置文件你需要在当前配置文件中使用 M-x load-file 双击两次回车确认默认文件名，或者使用 -x eval-buffer 去执行当前缓冲区的所有 Lisp 命令。 你也可以使用 C-x C-e 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效. 5. 插件管理使用默认的插件管理系统（在菜单栏 Options &gt; Manage Emacs Packages 中找到）安装 Company 插件，是一个用于代码补全的插件。它的名字代表补全一切的意思（ Comp lete Any thing）。 ;; 开启全局 Company 补全(global-company-mode 1) 6. Org-mode分级标题* 为一级标题** 为二级标题*** 为三级标题并以此类推 作为 GTD 工具进行时间管理C-c C-t 切换 TODO -&gt; DONE -&gt; NONE","link":"/emacs-note/"},{"title":"关于 VS Code 中 \"Classpath is incomplete\" warning","text":"问题概述每当打开一个 java 文件时，它不属于项目（我们称之为独立的 java 文件），vscode-java 无法计算正确的类路径。它使报告编译错误变得毫无用处，因为 UI 会在整个文件中填充令人分心的红色错误，例如： 幸运的是，vscode-java 仍然能够为基本 JDK 类提供有用的内容辅助，报告语法错误，计算类大纲或允许代码导航。因此，显示以下警告： 如果您只是关闭消息，它将在下次打开独立的 java 文件时弹出。通过单击Don’t Show Again 选项，可以永久地丢弃该消息。 如果改变主意，可以在 VS Code 的用户设置中修改该选项：java.errors.incompleteClasspath.severity 键指定当 java 文件的类路径不完整时消息的严重性。支持的值包括 ignore, info, warning 和 error。 您需要打开一个包含 pom.xml, build.gradle 或至少是默认 eclipse 设置文件的文件夹，以便可以设置完整的类路径和项目层次结构。 Android 项目基于 Gradle 的 Android 项目目前显示此消息，因为目前不支持 Android 开发。这是 limitation of BuildShip，该项目提供 Gradle 支持。 参考：https://github.com/redhat-developer/vscode-java/wiki/%22Classpath-is-incomplete%22-warning","link":"/vscode-warning-classpath-is-incomplete/"},{"title":"同一客户端下使用多个 Git 账号","text":"我们在日常使用 Git 进行文件管理时，避免不了会使用多个账号的情况。自己在家开发一些小项目就托管在 Github 上面，而在公司的话会用到另外一个账号，可能是 GitLab 账号进行管理，或者是自己想要搭建一个个人博客并托管在另一个账号，那么单纯的 HTTPS 就不足以支持两个账号在同一客户端进行使用了，这时就需要用到 SSH 来进行管理。 PS: 这篇博客主要是想要记录自己多个 Git 账号的配置过程，以备查阅。 1. 清除 Git 的全局设置git config --global --unset user.namegit config --global --unset user.email 2. 生成新的 SSH keys用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pubssh-keygen -t rsa -C \"new email\" 在生成第一组 id_rsa 和 id_rsa.pub_ 可以选用默认的文件名，在出现提示输入文件名的时候要输入一个不同的文件名，比如： 这里填的是 id_rsa_new Enter file in which to save the key (~/.ssh/id_rsa): id_rsa_new 注： Windows 用户和 Mac 用户的区别就是，mac 中 .ssh 文件夹在根目录下，所以表示成 ~/.ssh/，而 Windows 用户是 C:\\Users\\Administrator\\.ssh。 执行 ssh-agent 让 ssh 识别新的私钥因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中： ssh-add ~/.ssh/id_rsa_new 如果出现 Could not open a connection to your authentication agent 的错误，就试着用以下命令： ssh-agent bashssh-add ~/.ssh/id_rsa_new 3. 配置 ~/.ssh/config 文件# 该文件用于配置私钥对应的服务器Host git@github.com # 别名，随便定 后面配置地址有用 HostName https://github.com User git IdentityFile ~/.ssh/id_rsa # 密钥文件的地址，注意是私钥# second user(second@mail.com)Host git@code.xxxxxxx.com HostName https://code.xxxxxxx.com User git IdentityFile ~/.ssh/id_rsa_new PS: HostName 如果添加 https:// 前缀可能发生 public key 不能识别的情况，所以可以直接改为 github.com 4. 添加新的 SSH keys 到新账号的 SSH 设置中5. 测试一下$ ssh -T git@github.com # 此处是 Host 后面定义的别名Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.# 上面是 github 的成功返回语句，下面是 gitlab 的成功返回语句。$ ssh -T git@xxxxxx.comWelcome to GitLab, xxx! 链接：https://www.jianshu.com/p/89cb26e5c3e8/来源：简书 参考资料https://blog.csdn.net/onTheRoadToMine/article/details/79029331/ https://gist.github.com/suziewong/4378434/","link":"/git-one-more-account/"},{"title":"Mac 上好用的 APP 整理","text":"我整理了一些自己平常在 Mac 上经常用到的 APP，大家可以参考一下。另外我提供了项目网站和下载页面的地址。 文本编辑：Atom Atom 是由 GitHub 专门为程序员推出的跨平台文本编辑器，支持 CSS，HTML，JavaScript 等网页编程语言。 Emacs Emacs 是被公认为程序员最喜爱的代码编辑器之一，另外一个是 Vim。Emacs 使用 Emacs Lisp 这种极具扩展性的编程语言，实现了包括编程、编译乃至网络浏览等功能的扩展。 Sublime Text 3 Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 MacDown MacDown 是一款 Mac 下的 Markdown 编辑器。由于 Mou 的作者曾宣布不再继续该软件的开发并寻求出售所有权，所以 Macdown 的作者决定自己开发，MacDown 的很大一部分受到了 Mou 的影响。 效率工具：Alfred Alfred 是 Mac 下最流行的提升效率的工具。 AppCleaner AppCleaner 是 macOS 上的超轻量卸载专家。 Magnet Magnet 是 macOS 上进行窗口管理的快捷工具。 Pock Pock 是一款 macOS App，你可以通过它把 Touch Bar 变成系统中的 Dock 栏，直接用来切换和启动 App。 QSpace QSpace 是一款简洁高效的多视图文件管理器。 Sip Sip 是 macOS 上一款非常不错的取色软件。 清理工具：Tencent Lemon Tencent Lemon 是 macOS 上的一款清理软件，在 AppStore 上提供 Lite 版本的下载。 播放器：IINA IINA 是一个现代的 macOS 视频播放器。 通讯：Telegram Telegram 是一款跨平台的实时通讯软件。 云盘：Mega Mega 是一款云储存服务，免费版账户提供 35G 的云储存空间。 Seafile Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。普通用户提供 2GB 的储存空间。 VPN 服务Windscribe Windscribe 是一款跨平台的 VPN 服务，普通用户每月有 10GB 的免费流量。","link":"/awesome-mac-apps/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hanoi","slug":"Hanoi","link":"/tags/Hanoi/"},{"name":"Emacs","slug":"Emacs","link":"/tags/Emacs/"},{"name":"Elisp","slug":"Elisp","link":"/tags/Elisp/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"笔记","slug":"Java/笔记","link":"/categories/Java/笔记/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"算法","slug":"C/算法","link":"/categories/C/算法/"},{"name":"开发工具","slug":"Git/开发工具","link":"/categories/Git/开发工具/"}]}