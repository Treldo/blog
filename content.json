{"pages":[{"title":"","text":"个人介绍 本科在读 喜欢写一些归纳类的文章 联系方式 邮箱：vuebee@163.com","link":"/about/index.html"},{"title":"algs4-1.1 基础编程模型","text":"1. 原始数据类型与表达式原始数据类型 &ensp;8 位整数，byte 16 位整数，short 32 位整数，int 64 位整数，long 16 位字符，char 32 位单精度实数，float 64 位双精度实数，double 表达式 Java 中使用 中缀 表达式，即：运算符在字面量或表达式之间。 逻辑运算符中 ! 拥有最高优先级，之后是 &amp;&amp;，然后是 ||。 2. 语句 声明语句：Java 是强类型语言，编译器会检查类型的一致性。 赋值语句：左侧必须是单个变量，右侧是能够得到相应类型的任意表达式。 条件语句：不同操作来处理不同的输入，分为 if 语句和 switch 语句。 循环语句：主要是 while 语句和 for 语句，循环语句中的代码称为循环体。 调用和返回语句：与静态方法有关，是执行流程和代码组织的另一种方式。 其他语句 break 语句：退出循环。 continue 语句：立即开始下一轮循环。 return 语句：返回值。 3. 数组 对于数组 a[]，程序可以通过 a.length() 获取数组长度。 可能出现的异常 ArrayIndexOutOfBoundsException 数组别名当我们将一个数组变量赋给另一个变量，那么两个变量都会指向同一个数组。 int[] a = new int[N];a[i] = 123;int[] b = a;b[i] = 456;System.out.print(a[i]); // 此处输出 a[i] 的值为 456 4. 静态方法静态方法是一组在被调用时会被顺序执行的语句，拥有修饰符 static，区别于实例方法。 方法的性质 方法的参数按值传递：方法中使用的参数变量可以引用调用者的数组并改变其内容，但不能改变与原数组变量本身（值传递）。也就是在方法中改变一个参数变量的值对调用者本身没有影响。 方法名可以被重载：例如同名方法可以传入多种参数类型。 方法只能返回一个值，但可以包含多个返回语句：返回被执行语句中第一条返回语句的参数。 方法可以产生副作用：void 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或改变系统状态）。 递归方法可以调用自己；递归代码比相应的非递归代码更加简洁优雅、易懂。 最简单的情况：方法的第一条语句总是一个包含 return 的条件语句。 递归的调用总是去尝试解决规模更小的子问题，这样递归才能收敛到最简单的情况。 递归调用的父问题和尝试解决的子问题之间不应该有交集。 // 二分查找的递归实现public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1);}public static int rank(int key, int[] a, int lo, int hi) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi); } else { return mid; }} 基础编程模型Java 开发的基本模是编写一个静态方法库（包含一个 main() 方法）来完成一个任务。 模块化编程我们可以构造许多个静态方法库（模块），一个库中的静态方法也可以调用另一个库中定义的静态方法。这能够带来很多好处： 程序整体的代码量很大时，每次处理的模块大小仍然适中； 可以共享和重用代码而无需重新实现； 很容易用改进的实现替换旧的实现； 可以为解决编程问题建立合适的抽象模型； 缩小测试范围。 单元测试每一个静态方法库中都包含一个 main() 函数来测试库中的所有方法（有些编程语言不支持多个 main() 方法，所以不支持这种方式）。我们可以将 main() 方法作为一个开发用例，在开发过程中用它来测试更多的细节；也可以将它编写成一个测试用例来对所有代码进行一个全面的测试。当用例越来越复杂，我们可能会将它独立成一个模块。 外部库 系统标准库 java.lang.*：包括实现了常用数学函数的 Math 库以及其他。 导入的系统库，例如 java.util.Arrays：需要在程序的开头使用 import 语句导入。 5. API模块化编程的一个重要组成部分就是记录库方法的用法并提供其他人参考的文档；我们应该将自己编写的每一个程序都当作一个日后可以重用的库。关于 API 的说明可参考 什么是 API ？ 6. 输入输出重定向与管道重定向将程序的输出重定向至一个文件： % java RandomSeq 1000 100.0 200.0 &gt; data.txt 重定向标准输入使从文件中读取数据： % java Average &lt; data.txt 管道将一个程序的输出重定向为另一个程序的输入叫做管道： % java RandomSeq 1000 100.0 200.0 | java Average 突破了能够处理的输入输出流的限制 运行的先后顺序由操作系统决定 7. 白名单过滤信用卡公司的例子： 将客户账号保存在一个文件中，称为白名单； 从标准输入中得到每笔交易的账号； 使用测试用例在标准输出中打印所有与客户无关的账号，公司很可能拒绝此类交易。 % java BinarySearch tinyW.txt &lt; tinyT.txt 此处的 tinyW.txt 就是一个白名单。 知识点+ Java 中一个静态方法不能作为另一个静态方法的参数，但在一些其他语言中可以。 习题见 习题 1-1","link":"/independent-pages/list/algs4/1/1.1/index.html"},{"title":"algs4-1.2 数据抽象","text":"抽象数据类型 （ADT） 是一种能够对使用者隐藏数据表示的数据类型。使用抽象数据类型时，我们的注意力集中在 API 描述的操作上而不会去关心数据的表示；实现抽象数据类型时，我们的注意力集中在数据本身并将实现对该数据的各种操作。 以适用于各种用途的 API 形式准确地定义问题； 用 API 的实现描述算法和数据结构。 特点：可以在不修改任何用例代码的情况下使用一种算法替换另一种算法并改进所有用例的性能。 1. 使用抽象数据类型抽象数据类型的 API抽象数据类型的定义和静态方法库之间的共同点： 两者的实现均为 Java 类； 实例方法可以接受 0 个或多个指定类型的参数，由括号表示并由逗号分隔； 可能返回指定类型的值。 不同点： API 中会出现名称和类名相同的没有返回值的构造函数； 实例方法不需要 static 关键字，目的是操作数据类型中的值； 尊重 Java 习惯而存在的继承方法，在 API 中显示为灰色。 继承的方法大致有 toString() 、equals() 、compareTo() 、hashCode()。在使用 “+” 运算符将任意数据类型的值和 String 值连接时会调用 toString() 方法。 对象对象的创建与使用调用 new() 时，系统会： 为新的对象分配内存空间； 调用构造函数初始化对象中的值； 返回该对象中的一个引用。 静态方法的主要作用是实现函数；非静态（实例）方法的主要作用是实现数据类型的操作。一个开头是类名，一个开头是对象名。 开发某种给定数据类型的用例： 声明该类型变量，以用来引用对象； 使用关键字 new 触发能够创建该类型的对象的一个构造函数； 使用变量名在语句或表达式中调用实例方法。 使用与对象关联的变量： 赋值语句； 向方法传递对象或是从方法中返回对象； 创建并使用对象的数组。 赋值语句 不会创建对象，而是创建另一个指向某个已经存在的对象的引用。这种情况称为 别名 ：两个变量同时指向同一个对象。 对于原始数据类型的变量，会发生值的复制。而对于引用类型，复制的是引用而非实际的值。例如： int a = 0;int b = a;b++;System.out.println(a);System.out.println(b); 此时输出的 a 的值为 0，b 的值为 1。再试着运行下面的程序： public class Test { public static void main(String[] args) { Num num = new Num(4); Num num2 = num; num2.add(2); System.out.println(num.getValue()); }}class Num { private int value; Num(int value) { this.value = value; } int getValue() { return value; } void add(int increment) { value += increment; }} 这是将对象作为参数的情况。我们可以发现 num.value 的值随着 num2 对 add() 方法的调用改变了。 PS: 方法无法改变原始的引用，但能够改变对象的值。 Java 中的方法只能有一个返回值，如果使用对象的话，实际上就能够返回多个值。 数组与对象Java 中所有非原始数据类型的值都是对象。这样一来，数组也是对象。 创建一个对象数组： 使用方括号语法调用数组的构造函数创建数组； 对于每个数组元素，调用它的构造函数创建相应的对象。 Java 中的对象数组实际上是一个由对象的引用组成的数组。如果对象非常大，在移动对象时只需要移动对象的引用，这样大大提高了效率；而对象非常小的时候，每次获取信息都需要通过引用来操作反而降低了效率。 对象的三大关键性质：状态、标识和行为。 一个数据类型的实现所支持的操作： 创建对象（创造它的标识）：使用 new 关键字触发构造函数并创建对象，初始化对象中的值并返回它的引用。 操作对象中的值（控制对象的行为，可能会改变对象的状态）：使用对象关联的变量调用实例方法来对对象中的值进行操作。 操作多个对象：创建对象的数组，像原始数据类型的值一样将它们传递给方法或是从方法中返回，只是变量关联的是对象的引用而非对象本身。 2. 抽象数据类型举例几何对象信息处理字符串String a = \"now is \";String b = \"the time \";String c = \"to\"; 方法 返回值 a.length() 7 a.charAt(4) i a.concat(c) “now is to” a.indexOf(&quot;is&quot;) “w i” a.substring(2, 5) “now” a.split(&quot; &quot;)[0] “now” a.split(&quot; &quot;)[1] “is” b.equals(c) false 3. 抽象数据类型的实现 实例变量：每个实例变量的声明都需要一个 可见性修饰符。 构造函数 实例方法 作用域 API、用例与实现 实例变量如果使用 public 修饰的话，根据定义，这种数据类型就不是抽象的了。所以一般不会这么做。 构造函数 类似于静态方法，能够直接访问变量并且没有返回值； 每一个构造函数都会创建一个对象并向调用者返回一个该对象的引用； 名称与类型相同； 支持重载； 如果没有构造函数，将会隐式定义 0，false，null 的默认值（前提是参数没有提供默认值）。 实例方法同静态方法大都是语法上的区别。 作用域 参数变量：整个方法。 局部变量：当前代码段中定义之后的所有语句。 实例变量：整个类。 如果实例变量出现二义性，可以使用 this 进行区别。 4. 更多抽象数据类型的实现维护多个实现 通过前缀描述性修饰符进行区别； 维护一个没有前缀的参考实现以适用大多数用例的需求。 累加器维护一个 int 类型的实例变量来记录已经处理过的数据值的数量，以及一个 double 类型的实例变量来记录所有数据之和，除以数据数量得到平均值。 实现 public class Accumulator { private double total; private int N; public void addDateValue(double val) { N++; total += val; } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestAccumulator { public static void main(String[] args) { // 如果不想使用终端输入命令的方式，此处也可以改为 // int T = StdIn.readInt(); // 如此就可以在输入端输入 T 值 int T = Integer.parseInt(args[0]); Accumulator a = new Accumulator(); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法 % java TestAccumulator 1000Mean (1000 values): 0.51829 可视化的累加器使用 StdDraw 画出所有数据（灰色）和实时平均值（红色）。 实现 public class VisualAccumulator { private double total; private int N; public VisualAccumulator(int trials, double max) { StdDraw.setXscale(0, trials); StdDraw.setYscale(0, max); StdDraw.setPenRadius(.005); } // 副作用：实现绘图 public void addDateValue(double val) { N++; total += val; StdDraw.setPenColor(StdDraw.DARK_GRAY); StdDraw.point(N, val); StdDraw.setPenColor(StdDraw.RED); StdDraw.point(N, total / N); } public double mean() { return total / N; } public String toString() { return \"Mean (\" + N + \" values): \" + String.format(\"%7.5f\", mean()); }} 用例 public class TestVisualAccumulator { public static void main(String[] args) { int T = Integer.parseInt(args[0]); VisualAccumulator a = new VisualAccumulator(T, 1.0); for (int t = 0; t &lt; T; t++) { a.addDateValue(StdRandom.random()); } StdOut.println(a); }} 用法与 Accumulator 用法一致。 5. 数据类型的设计 省略，待更新 知识点+ 原始数据类型更接近计算机硬件所支持的数据类型，使用起来要要快于引用类型。 有时候会用私有实例方法在公有方法之间共享代码。 没有使用 new 关键字创建对象得到的 错误 与引用一个未定义符号相同，构造函数的参数数量不对也会出现相同的错误信息。 创建对象数组每一个对象都需要使用 new 关键字：没有创建数组与为一个未初始化的变量赋值得到的 错误 相同。如果尝试调用未初始化对象的方法，会得到 空指针异常 。 println() 接受一个 Object 对象。 指针是什么？ 实现引用的一种自然方式是使用指针（机器地址），另一种可能是句柄（指针的指针）。前者访问数据的速度很快，后者能够更好地实现垃圾回收。 继承的问题：子类代码可以访问所有实例变量，因此可以改变值。 类中的所有方法都可以访问静态变量。静态变量的作用域是全局的，所以使用时要非常小心。 不再被支持但为了保持兼容性而留在 API 中的方法叫做被弃用（deprecated）的方法。 习题见 习题 1-2","link":"/independent-pages/list/algs4/1/1.2/index.html"},{"title":"algs4 习题 1-2","text":"练习 部分用例的用法 % javac Testxxx.java% java Testxxx [args] 以下出现 Integer.parseInt(args[x]) 的地方均可以替换为 StdIn.readxxx() ，不过这样变成了从标准输入中读取数据。题中要求从命令行接受数据，所以最好避免从标准输入中进行数据的获取。 1. Point2D 用例public class TestPoint2D { public static void main(String[] args) { int N = Integer.parseInt(args[0]); Point2D[] points = new Point2D[N]; for (int i = 0; i &lt; N; i++) { points[i] = new Point2D(Math.random(), Math.random()); points[i].draw(); } if (N &gt; 1) { double min = points[0].distanceTo(points[1]); for (int i = 0; i &lt; N - 1; i++) { for (int j = i + 1; j &lt; N; j++) { if (points[i].distanceTo(points[j]) &lt; min) { min = points[i].distanceTo(points[j]); } } } System.out.println(\"The min distance: \" + min); } }} 2. Interval1D 用例public class TestInterval1D { public static void main(String[] args) { int N = Integer.parseInt(args[0]); Interval1D[] intervals = new Interval1D[N]; for (int i = 0; i &lt; N; i++) { intervals[i] = new Interval1D(StdIn.readDouble(), StdIn.readDouble()); } for (int i = 0; i &lt; N - 1; i++) { for (int j = i + 1; j &lt; N; j++) { if (intervals[i].intersects(intervals[j])) { StdOut.println(intervals[i] + \" -- \" + intervals[j]); } } } }} 3. Interval2D 用例public class TestInterval2D { private static int intersectCount = 0; private static int containCount = 0; private static double max(double a, double b) { return Math.max(a, b); } private static double min(double a, double b) { return Math.min(a, b); } public static void main(String[] args) { int N = Integer.parseInt(args[0]); double min = Double.parseDouble(args[1]); double max = Double.parseDouble(args[2]); // 设置绘图范围（可以保证所有矩形都绘制在窗格内） StdDraw.setXscale(min, max); StdDraw.setYscale(min, max); // 供判断 contains 条件的点集合 Point2D[] leftTopPoints = new Point2D[N]; Point2D[] rightBottomPoints = new Point2D[N]; Interval2D[] interval2DS = new Interval2D[N]; for (int i = 0; i &lt; N; i++) { double x1 = StdRandom.uniform(min, max); double x2 = StdRandom.uniform(min, max); double y1 = StdRandom.uniform(min, max); double y2 = StdRandom.uniform(min, max); leftTopPoints[i] = new Point2D(min(x1, x2), min(y1, y2)); rightBottomPoints[i] = new Point2D(max(x1, x2), max(y1, y2)); interval2DS[i] = new Interval2D(new Interval1D(min(x1, x2), max(x1, x2)), new Interval1D(min(y1, y2), max(y1, y2))); interval2DS[i].draw(); } for (int i = 0; i &lt; N - 1; i++) { for (int j = 1; j &lt; N; j++) { if (interval2DS[i].intersects(interval2DS[j])) { intersectCount++; } if (interval2DS[i].contains(leftTopPoints[j]) &amp;&amp; interval2DS[i].contains(rightBottomPoints[j])) { containCount++; } } } StdOut.println(\"Intersect count: \" + intersectCount); StdOut.println(\"Contain count: \" + containCount); }} 4. 单纯的值传递worldhello 5. String 对象不可变所有的字符串方法都不会改变参数对象的值，而是返回一个新的 String 对象。 6. 回环变位 书中提示的方法 if ((s + s).indexOf(t) &gt;= 0) {}; 使用了字符串拼接的方法 if (s.concat(s).contains(t)) {}; 7. 递归函数的返回值返回一个倒序的字符串。 8. 数组引用复制的是引用，不是数据。原始数据类型才会将数据复制下来，其余复制的都是对象的引用。 9. BinarySearch 中增加 Counter我这里又定义了一个 Counter 类，以便于对记录值进行修改。 class Counter { private int val = 0; public int getVal() { return val; } public void add() { val++; }}public class BinarySearch { public static int rank(int key, int[] a, Counter counter) { return rank(key, a, 0, a.length - 1, counter); } public static int rank(int key, int[] a, int lo, int hi, Counter counter) { // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { counter.add(); return rank(key, a, lo, mid - 1, counter); } else if (key &gt; a[mid]) { counter.add(); return rank(key, a, mid + 1, hi, counter); } else { counter.add(); return mid; } } public static void main(String[] args) { Counter counter = new Counter(); int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.println(rank(6, a, counter)); System.out.println(counter.getVal()); }} 10. 类 VisualCounter 实现： public class VisualCounter { private int val; private int N; private int max; // 用来记录操作次数 private int counter = 0; public VisualCounter(int N, int max) { this.N = N; this.max = max; StdDraw.setXscale(0, N); StdDraw.setYscale(0, max); StdDraw.setPenColor(StdDraw.RED); StdDraw.setPenRadius(.01); } public void add() { if (val &lt; max &amp;&amp; counter &lt; N) val++; StdDraw.point(counter, val); counter++; } public void reduce() { if (counter &lt; N) val--; StdDraw.point(counter, val); counter++; }} 用例： public class TestVisualCounter { public static void main(String[] args) { VisualCounter counter = new VisualCounter(100, 100); for (int i = 0; i &lt; 50; i++) { counter.add(); } for (int i = 0; i &lt; 30; i++) { counter.reduce(); } for (int i = 0; i &lt; 20; i++) { counter.add(); } }} 11. SmartDate 类这里定义了 年-月-日-时-分-秒 这六个变量，设置了四个构造器，提供了对变量进行操作和得到当前星期的方法。因为代码比较易懂，所以这里就不会多作说明了。书上 表1.2.12 中 Date 类的另一种实现还挺有意思的，有兴趣的同学可以看一下，另外还可以阅读 edu.princeton.cs.algs4 包中 Date 类的 源码 。 当日期信息错误时，会报异常：java.lang.IllegalArgumentException: Illegal date message.当时间信息错误时，会报异常：java.lang.IllegalArgumentException: Illegal time message. PS: 没有注意到书中提供的 Date 的 API 😂，所以可能同书中的要求有所不同，变化不大，就不作修改了。 实现： public class SmartDate { private int year; private int month; private int date; private int hrs; private int min; private int sec; public SmartDate(int year, int month, int date) { this(year, month, date, 0, 0, 0); } public SmartDate(int year, int month, int date, int hrs) { this(year, month, date, hrs, 0, 0); } public SmartDate(int year, int month, int date, int hrs, int min) { this(year, month, date, hrs, min, 0); } public SmartDate(int year, int month, int date, int hrs, int min, int sec) { if (year &gt;= 0) { switch (month) { default: if (hrs &gt;= 0 &amp;&amp; hrs &lt;= 23) { if (min &gt;= 0 &amp;&amp; min &lt;= 59) { if (sec &gt;= 0 &amp;&amp; sec &lt;= 59) { this.hrs = hrs; this.min = min; this.sec = sec; } } } else { throw new IllegalArgumentException(\"Illegal time message.\"); } case 1: case 3: case 5: case 7: case 8: case 10: case 12: if (date &gt;= 1 &amp;&amp; date &lt;= 31) { if (hrs &gt;= 0 &amp;&amp; hrs &lt;= 23) { this.year = year; this.month = month; this.date = date; } } else { throw new IllegalArgumentException(\"Illegal date message.\"); } break; case 4: case 6: case 9: case 11: if (date &gt;= 1 &amp;&amp; date &lt;= 30) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } break; case 2: if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) { if (date &gt;= 1 &amp;&amp; date &lt;= 29) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } else { if (date &gt;= 1 &amp;&amp; date &lt;= 28) { this.year = year; this.month = month; this.date = date; } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } } } else { throw new IllegalArgumentException(\"Illegal date message.\"); } } public int getDayOfWeek() { return (date + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400) % 7; } public int getYear() { return year; } public void setYear(int year) { this.year = year; } public int getMonth() { return month; } public void setMonth(int month) { this.month = month; } public int getDate() { return date; } public void setDate(int date) { this.date = date; } public int getHrs() { return hrs; } public void setHrs(int hrs) { this.hrs = hrs; } public int getMin() { return min; } public void setMin(int min) { this.min = min; } public int getSec() { return sec; } public void setSec(int sec) { this.sec = sec; }} 测试用例： public class TestSmartDate { public static void main(String[] args) { SmartDate date = new SmartDate(2019, 8, 27); System.out.println(date.getDayOfWeek()); }} 12. 方法 dayOfTheWeek()上面已经有了 SmartDate 类的源码，这里只给出方法的实现。 public String dayOfTheWeek() { int index = (date + 1 + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400) % 7; switch (index) { case 0: return \"Sunday\"; case 1: return \"Monday\"; case 2: return \"Tuesday\"; case 3: return \"Wednesday\"; case 4: return \"Thursday\"; case 5: return \"Friday\"; case 6: return \"Saturday\"; default: return null; }} 13. Transaction 类型参考了一下 edu.princeton.cs.algs4 包里的 Transaction 类，发现写这个类型是为了记录交易信息，类中包含了 人-时间-交易数目 。有兴趣的同学可以阅读 edu.princeton.cs.algs4 包中 Transaction 类的 源码 。 // 刚刚才写了 SmartDate 类，那我们就使用它来代替 Date 吧！public class Transaction { private final String who; private final SmartDate date; private final double amount; public Transaction(String name, SmartDate date, double amount) { who = name; this.date = date; this.amount = amount; } public String who() { return who; } public SmartDate date() { return date; } public double amount() { return amount; } public String toString() { return who() + \"/\" + date() + \"/\" + amount(); }} 14. Transaction 类的 equals() 方法这个方法是完全仿照书上 Date 类中的 equals() 方法写的。 public boolean equals(Object x) { if (this == x) return true; if (x == null) return false; // 如果两者的类型不同则返回 false 值 if (this.getClass() != x.getClass()) return false; // 类型转换 Transaction that = (Transaction) x; if (this.who != that.who) return false; if (this.date != that.date) return false; if (this.amount != that.amount) return false; return true;} 提高题 待更新","link":"/independent-pages/src/algs4/1/1.2/index.html"},{"title":"algs4 习题 1-1","text":"知乎上有一篇总结的还不错, 如果觉得不够详细，或者想要参考题目以及其他答案的同学，可以在 这里 找到。 练习1. 表达式的值&emsp;a. 7&emsp;b. 200.0000002&emsp;c. true 2. 类型和值&emsp;a. double, 1.618&emsp;b. double, 10.0&emsp;c. boolean, true&emsp;d. String, 33 3. equal 判断import java.util.Scanner;public class Test { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); if (a == b &amp;&amp; b == c) { System.out.println(\"equal\"); } else { System.out.println(\"not equal\"); } }} 4. 语句修正if (a &gt; b) c = 0; else b = 0; 5. 范围判断import java.util.Scanner;public class Test { public static boolean right(double d) { if (d &gt;= 0.0 &amp;&amp; d &lt;= 1.0) { return true; } else { return false; } } public static void main(String[] args) { Scanner sc = new Scanner(System.in); double x = sc.nextDouble(); double y = sc.nextDouble(); if (right(x) &amp;&amp; right(y)) { System.out.println(\"true\"); } else { System.out.println(\"false\"); } }} 6. Fibnonacci 数列// 斐波那契数列的非递归算法int f = 0;int g = 1;for (int i = 0; i &lt;= 15; i++) { System.out.println(f); f = f + g; g = f - g;} 结果01123581321345589144233377610 7. 打印的值&emsp;a. 3.00009&emsp;b. 499500&emsp;c. 10000 8. 打印结果&emsp;a. b&emsp;b. 197&emsp;c. e 9. 正整数二进制 Java 中有内置方法 Integer.toBinaryString(); // 一个简洁的实现方法String s = \"\";for (int n = N; n &gt; 0; n /= 2) { s = (n % 2) + s;} 10. 代码存在的问题没有用 new 为 a[] 分配内存，会产生一个 variable a might not have been initialized 的编译错误。 int[] a;for (int i = 0; i &lt; 10; i++) { a[i] = i * i;} 11. 打印二维布尔数组// 已初始化 boolean 类型二维数组 bfor (boolean[] booleans : b) { System.out.print(lineNumber++ + \"| \"); for (boolean aBoolean : booleans) { if (aBoolean) { System.out.print(\"*\"); } else { System.out.print(\" \"); } } System.out.println();} 12. 打印结果此处书中有误，代码段应为： int[] a = new int[10];for (int i = 0; i &lt; 10; i++) a[i] = 9 - i;for (int i = 0; i &lt; 10; i++) a[i] = a[a[i]];for (int i = 0; i &lt; 10; i++) System.out.println(i); 结果0123443210 13. 二维数组的转置// 使用 int 类型数组举例，已初始化数组 a[M][N]int[][] temp = new int[N][M];for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][j] = a[j][i]; System.out.print(temp[i][j] + \" \"); } System.out.println();} 14. 返回不大于 log₂N 的最大整数public static int lg(int N) { int result = 0; int temp = 2; while (temp &lt; N) { temp *= 2; result++; } return result;} 15. 返回长度为 M 的数组public static int[] histogram(int[] a, int M) { int[] temp = new int[M]; for (int i = 0; i &lt; M; i++) { for (int value : a) { if (i == value) temp[i]++; } } return temp;} 16. exR1(6) 的返回值311361142246 17. 递归函数的问题这段代码中的基础情况永远不会被访问。调用 exR2(3) 会产生调用 exR2(0)、exR2(-3) 和 exR2(-6)，循环往复直到发生 StackOverflowError。 18. 考察乘法与乘方的递归实现 修改前： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a + a, b / 2); return mystery(a + a, b / 2) + a;} 返回值 mystery(2, 25) = 50mystery(3, 11) = 33mystery(a, b) = a * b 核心思想： x * y = (x * 2 * 2 * ...) * (y / 2 / 2 / ...)PS: 此处的 x 可能为偶数，但 y 必为奇数。 修改后： public static int mystery(int a, int b) { if (b == 0) return 0; if (b % 2) return mystery(a * a, b / 2); return mystery(a * a, b / 2) * a;} 返回值 mystery(2, 25) = 33554432mystery(3, 11) = 177147mystery(a, b) = aᵇ 核心思想： x ^ y = (x ^ 2) ^ (y / 2) 19. 改进 F(N) 的实现书上的递归方法探究一小时之内能够得到 F(N) 结果最大的 N 值因为耗时比较长这里就不做尝试了。改进的方法可以参考 6 中的 斐波那契数列的非递归算法 ，下面的是按书上要求利用数组保存值的改进方法： public static long F(int N) { int[] a = new int[N]; a[0] = 0; a[1] = 1; for (int i = 2; i &lt; N; i++) { a[i] = a[i - 1] + a[i - 2]; } return a[N - 1];} 20. ln(N!) 的递归求解public static double ln(int N) { if (N == 0 || N == 1) { return; } else { return ln(N - 1) + Math.log(N); }} 21. 输入数据打印表格这里用到了 printf() 的格式化输出，不懂的同学请自行参考 菜鸟教程 。 System.out.print(\"Please input data count: \");Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();String[] nameArray = new String[n];int[] integerArray1 = new int[n];int[] integerArray2 = new int[n];for (int i = 0; i &lt; n; i++) { nameArray[i] = scanner.next(); integerArray1[i] = scanner.nextInt(); integerArray2[i] = scanner.nextInt();}System.out.println(\"|----------|-----|-----|-----|\");for (int i = 0; i &lt; n; i++) { System.out.printf(\"|%-10s|%-5d|%-5d|%.3f|\\n\", nameArray[i], integerArray1[i], integerArray2[i], ((double) integerArray1[i] / integerArray2[i])); System.out.println(\"|----------|-----|-----|-----|\");} 看到有一个比较有意思的解题方法，思路是用 split() 方法将得到的两行数据进行拆分。缺点是如果输入的数据不是以单个空格为间隔就会报 NumberFormatException 的异常。 Scanner sc = new Scanner(System.in);String[] a = new String[2];int index = 0;while (index &lt; a.length) { a[index] = sc.nextLine(); index++;}for (String s : a) { String[] stringArr = s.split(\" \"); int num1 = Integer.parseInt(stringArr[1]); int num2 = Integer.parseInt(stringArr[2]); System.out.printf(\"%-10s%-5d%-5d%.3f\\n\", stringArr[0], num1, num2, ((double) num1 / num2));} 22. BinarySearch-按递归深度缩进如果你忘记了之前的 rank() 方法，可以在 这里 找到它。下面来对它进行改写： public static int rank(int key, int[] a) { return rank(key, a, 0, a.length - 1, 1);}// 如果是在某一限定范围内进行查找，则需要手动传入参数 `deep` 的值// `deep` 的值需要设定在大于等于 1 的整数群中，否则在第 3 - deep 行中才会出现缩进效果public static int rank(int key, int[] a, int lo, int hi, int deep) { // 实现缩进 for (int i = 1; i &lt; deep; i++) { System.out.print(\" \"); } System.out.printf(\"%d. lo: %d hi: %d\\n\", deep, lo, hi); // 如果 key 存在于 a[] 中，它的索引不会小于 lo 且不会大于 hi if (lo &gt; hi) return -1; int mid = lo + (hi - lo) / 2; if (key &lt; a[mid]) { return rank(key, a, lo, mid - 1, deep + 1); } else if (key &gt; a[mid]) { return rank(key, a, mid + 1, hi, deep + 1); } else { return mid; }} 23. BinarySearch 的测试用例public static void main(String[] args) { int[] whiteList = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; System.out.print(\"Please input \\\"+\\\" or \\\"-\\\": \"); // 为避免读入多余字符使用了 edu.princeton.cs.algs4 包中 StdIn 类里的 readChar() 方法 char flag = StdIn.readChar(); // 读入第一个字符以外的其余字符（不作用途） StdIn.readLine(); System.out.print(\"Please input keys(Split with space): \"); String[] keyList = StdIn.readLine().split(\" \"); for (String s : keyList) { if (flag == '+') { if (rank(Integer.parseInt(s), whiteList) == -1) { System.out.printf(\"%s \", s); } } else if (flag == '-') { if (rank(Integer.parseInt(s), whiteList) != -1) { System.out.printf(\"%s \", s); } } } System.out.println(\"\\nDone!\");} 24. 欧几里得算法计算最大公约数public class Euclid { public static int euclid(int p, int q) { if (q == 0) { return p; } System.out.printf(\"p = %d, q = %d\\n\", p, q); // 交换值的目的是为了减小递归的运算次数 if (p &lt; q) { int temp = p; p = q; q = temp; } return euclid(q, p % q); } public static void main(String[] args) { int p = StdIn.readInt(); int q = StdIn.readInt(); System.out.println(\"\\nresult = \" + euclid(p, q)); }} 25. 数学归纳法证明欧几里得算法参考：&emsp;简书 - 欧几里得算法心得(辗转相除法)&emsp;百度文库 - 辗转相除法的证明 提高题 待更新","link":"/independent-pages/src/algs4/1/1.1/index.html"},{"title":"algs4-1.3 背包、队列和栈","text":"三种数据类型：背包（Bag）、队列（Queue）和栈（Stack）。它们的不同之处就在于删除或者访问对象的顺序不同。 1. API 表 1.3.1&emsp;泛型可迭代的基础集合数据类型的 API 背包 public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; Bag() 创建一个空背包 void add(Item item) 添加一个元素 boolean isEmpty() 背包是否为空 int size() 背包中的元素数量 先进先出（FIFO）队列 public class Queue&lt;Item&gt; implements Iterable&lt;Item&gt; Queue() 创建空队列 void enqueue(Item item) 添加一个元素 Item dequeue() 删除最早添加的元素 boolean isEmpty() 队列是否为空 int size() 队列中的元素数量 下压（后进先出，LIFO）栈 public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; Stack() 创建一个空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中的元素数量 泛型泛型也叫参数化类型。看个例子： Stack&lt;String&gt; stack = new Stack&lt;String&gt;();Queue&lt;Date&gt; queue = new Queue&lt;Date&gt;(); 如果向 stack 中添加 Date 对象（或是任何非 String 类型数据），或者是向 queue 中添加 String 对象（或是任何非 Date 类型数据），都会得到一个编译时的错误。 自动装箱类型参数必须被实例化为引用类型，在处理赋值语句、方法的参数和算术或逻辑表达式时，Java 会自动在引用类型和对应的原始数据类型之间进行转换。例如： Stack&lt;Integer&gt; stack = enw Stack&lt;Integer&gt;();stack.push(17); // 自动装箱 (int -&gt; Integer)int i = stack.pop(); // 自动拆箱 (Integer -&gt; int) 可迭代的集合类型直接上例子： // 假设在 Queue 中维护一个交易集合Queue&lt;Transaction&gt; queue = new Queue&lt;Transaction&gt;();// 如果集合是可迭代的，打印交易列表for (Transaction t : queue) { StdOut.println(t);} 背包背包不支持从中删除元素，迭代的顺序不确定且与用例无关。使用 Bag 就说明元素的处理顺序不重要，典型用例就是计算平均值和标准差: public class Stats { public static void main(String[] args) { Bag&lt;Double&gt; numbers = new Bag&lt;&gt;(); while (!StdIn.isEmpty()) numbers.add(StdIn.readDouble()); int N = numbers.size(); double sum = 0.0; for (double x : numbers) sum += x; double mean = sum / N; sum = 0.0; for (double x : numbers) sum += (x - mean) * (x - mean); double std = Math.sqrt(sum / (N - 1)); StdOut.printf(\"Mean: %.2f\\n\", mean); StdOut.printf(\"Std dev: %.2f\\n\", std); }} 先进先出（FIFIO）队列使用 foreach 语句迭代访问队列中的元素时，元素的处理顺序就是它们被添加到队列中的顺序。在应用程序中使用队列的主要原因就是它在保存元素的同时也保存了顺序，也就保证了入列和出列顺序相同。 队列的用例public static int[] readInts(String name) { // 在这里 in 对象的作用就是来保存传入的整型数组的元素作为 System.in 输入 In in = new In(name); Queue&lt;Integer&gt; q = new Queue&lt;&gt;(); while (!in.isEmpty()) q.enqueue(in.readInt()); int N = q.size(); int[] a = new int[N]; for (int i = 0; i &lt; N; i++) a[i] = q.dequeue(); return a;} 下压栈下压栈是一种基于后进先出（LIFO）策略的集合类型，叠书就是一个栈的例子。浏览网页时会遇到栈的另一个例子：单击“回退”按钮可以重新访问之前的页面。栈另一个特点就是将存入的数据逆序排列，下面的代码就是一个典型的例子： public class Reverse { public static void main(String[] args) { Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); while (!StdIn.isEmpty()) s.push(StdIn.readInt()); for (int i : s) StdOut.println(i); }} 算术表达式求值E.W.Dijkstra 发明了一个非常简单的算法，用到了两个栈（操作数栈、运算符栈）。具体思路： 将操作数压入（push）操作数栈； 将运算符压入运算符栈； 忽略左括号； 在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。 在处理完最后一个括号后，操作数栈上就只剩一个表达式的值。运算顺序： (1 + ((2 + 3) * (4 * 5)))(1 + (5 * (4 * 5)))(1 + (5 * 20))(1 + 100)101 Dijkstra 的双栈算术表达式求值算法public class Evaluate { public static void main(String[] args) { Stack&lt;String&gt; ops = new Stack&lt;&gt;(); // 运算符栈 Stack&lt;Double&gt; vals = new Stack&lt;&gt;(); // 操作数栈 while (!StdIn.isEmpty()) { // readString() 方法使用了 Scanner.next() 来读取字符串 String s = StdIn.readString(); if (s.equals(\"(\")); else if (s.equals(\"+\")) ops.push(s); else if (s.equals(\"-\")) ops.push(s); else if (s.equals(\"*\")) ops.push(s); else if (s.equals(\"/\")) ops.push(s); else if (s.equals(\"sqrt\")) ops.push(s); else if (s.equals(\")\")) { String op = ops.pop(); double val = vals.pop(); if (op.equals(\"+\")) val = vals.pop() + val; else if (op.equals(\"-\")) val = vals.pop() - val; else if (op.equals(\"*\")) val = vals.pop() * val; else if (op.equals(\"/\")) val = vals.pop() / val; else if (op.equals(\"sqrt\")) val = Math.sqrt(val); vals.push(val); } else vals.push(Double.parseDouble(s)); } StdOut.println(vals.pop()); }} 没有弄清楚这个用例很容易就会出现异常，或是计算出错误的结果。这是一个简单的算法的实现，它有几点要求： 输入的每个字符串都以空格隔开； 必须要有右括号（否则不能实现计算）； 每次只能进行两个操作数的运算； 开平方也是要需要加括号的。f 所以为了保险起见，还是要清晰一点。来个稍复杂一些的，比如要计算 12/(6-sqrt(2*8))，我们就这样写： ( 12 / ( 6 - ( sqrt ( 2 * 8 ) ) ) ) 用过 Emacs 学习了 emacs-lisp 或者学过 lisp 语言的同学可能会想，如果用 lisp 语法进行输入可不可以得到正确结果呢 🧐？同样计算上面式子，输入下面的内容，自己试一试：( / 12 ( - 6 ( sqrt ( * 2 8 ) ) ) ) 另外，如果使用 IDE 工具，想要结束输入需要按组合键 Ctrl + D（Windows）或 Command + D（Mac）。 2. 集合类数据类型的实现定容栈 表 1.3.2&emsp;一种表示定容字符串栈的抽象数据类型 API public class FixedCapacityStackOfStrings FixedCapacityStackOfStrings(int cap) 创建一个容量为 cap 的空栈 void push(String item) 添加一个字符串 String pop() 删除最近添加的字符串 boolean isEmpty() 栈是否为空 int size() 栈中的字符串数量 上面这个数据类型与栈的区别就在于它只能处理 String 值，要求用例指定一个容量且不支持迭代。 它的实例变量为一个用于保存栈中元素的数组 a[] ，和一个用于保存栈中元素数量的整数 N 。 添加和删除元素时 N 的值都会发生变化。 数据类型的实现public class FixedCapacityStackOfStrings { private String[] a; // 存储栈中元素的数组 private int N; // 记录数组大小 public FixedCapacityStackOfStrings(int cap) { a = new String[cap]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(String item) { a[N++] = item; } // 缩减数组大小，丢弃最后一个元素 public String pop() { return a[--N]; }} 理解了上面的实现，请务必完全理解下面的内容： 测试用例public static void main(String[] args) { FixedCapacityStackOfStrings s = new FixedCapacityStackOfStrings(100); while (!StdIn.isEmpty()) { String item = StdIn.readString(); if (!item.equals(\"-\")) s.push(item); else if (!s.isEmpty()) StdOut.print(s.pop() + \" \"); } StdOut.println(\"(\" + s.size() + \" left on stack)\");} 输入数据 to be or not to - be - - that - - - is 会得到结果 to be not that or be 那么符号 “-” 的作用究竟是什么呢？请仔细思考。 泛型上面的例子可以使用泛型进行处理，这样做是有好处的，使用泛型就可以处理不仅仅是 String 类型的数据。 public class FixedCapacityStack&lt;Item&gt; {...} Item 是一个类型参数，可以理解为象征性的占位符。前面也有提到过泛型，这里需要记住的一点就是：Java 会使用类型参数 Item 来检查类型不匹配的错误。 如果我们想要创建一个泛型的数组，会想要这样写： Item[] a = new Item[cap]; 但其实这样做是不行的。由于某些历史和技术原因，Java 中并不允许创建泛型数组，感兴趣的同学可以： 参考知乎上的 回答 ； 阅读掘金上的文章 泛型的基本原理 ； 自行搜索（Google、百度、多吉搜索、秘迹搜）。 我们可以使用类型转换来解决这个问题： Item[] a = (Item[]) new Object[cap]; 这段代码能够达到我们需要的效果，但 Java 编译器会给出一条类似于这样的警告：Unchecked cast: 'java.lang.Object[]' to 'Item[]' ，不过可以忽略它。 表 1.3.4&emsp;一种表示泛型定容栈的抽象数据类型 API public class FixedCapacityStack FixedCapacityStack(int cap) 创建一个容量为 cap 的空栈 void push(Item item) 添加一个元素 Item pop() 删除最近添加的元素 boolean isEmpty() 栈是否为空 int size() 栈中的元素数量 使用泛型来实现数据类型后，代码也改变了： 数据类型的实现 public class FixedCapacityStack&lt;Item&gt; { private Item[] a; private int N; public FixedCapacityStack(int cap) { a = (Item[]) new Object[cap]; } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(Item item) { a[N++] = item; } public Item pop() { // 如果要避免数据游离，就参考下面的 pop() 实现 return a[--N]; }} 测试用例 public static void main(String[] args) { FixedCapacityStack&lt;String&gt; s = new FixedCapacityStack&lt;&gt;(100); while (!StdIn.isEmpty()) { String item = StdIn.readString(); if (!item.equals(\"-\")) s.push(item); else if (!s.isEmpty()) StdOut.print(s.pop() + \" \"); } StdOut.println(\"(\" + s.size() + \" left on stack)\");} 调整数组的大小在 Java 中，数组一旦创建，就不可以改变它的大小，栈使用的空间只能是这个最大容量的一部分。正常来说应该有一个 isFull() 的方法来判断栈是否已满，避免数据溢出。先不实现这个方法，我们通过修改数组的实现来动态调用数组的大小以保证数据存储的最大利用率。 实现一个将栈移动到另一个大小为 max 的数组中的方法：// 这里不允许使用其他类调用这个方法，所以使用了 private 修饰符private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[i]; } a = temp;} 这个方法所起到的间接作用就是扩大了数组 a[] 的大小。 修改 push() 方法，在数据量达到数组最大容量时，将数组的容量扩大到 2 倍。 public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item;} 修改 pop() 方法，在数据量不及总容量的 1/4 时，缩减数组容量到 1/2： public Item pop() { Item item = a[--N]; // 避免对象游离（见下节） a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item;} 这里将最小数据量控制在 1/4 ，栈永远不会溢出，使用率不会低于 1/4（除了栈为空的情况）。 PS: 这里请自行理解。 对象游离在上面使用 pop() 方法弹出了一个元素，它就不会再被访问了，但数组中的引用仍可以让它继续存在。像这种保存一个不需要的对象的引用的情况就称之为游离。 为了避免游离，我们只需要将弹出的元素值设置为 null，这会覆盖无用的引用，并使系统在该元素使用完毕后回收它的内存。 迭代我们知道 foreach 语句可以迭代访问集合中的数据，其实它本质上与 while 语句是等价的，看这两组代码： Stack&lt;String&gt; collection = new Stack&lt;&gt;();for (String s : collection) StdOut.println(s); Stack&lt;String&gt; collection = new Stack&lt;&gt;();Iterator&lt;String&gt; i = collection.iterator();while (i.hasNext()) { String s = i.next(); StdOut.println(s);} 可迭代的集合的集合数据类型需要： 实现一个 iterator() 方法并返回一个 Iterator 对象； Iterator 类必须包含两个方法：hasNext()（返回一个 boolean 值）和 next()（返回一个集合中的泛型元素）。 对与可迭代的数据类型，Java 中定义了所需接口 java.lang.Iterable ： public interface Iterable&lt;Item&gt; { Iterator&lt;Item&gt; iterator();} 我们使用接口机制来指定一个类所必须实现的方法，所以在一个需要迭代的集合中我们必须实现接口中的 iterator() 方法。 要逆序迭代遍历整个数组，我们定义一个名为 ReverseArrayIterator 的迭代器的类来实现 Iterator 接口（意味着需要实现 Iterator 接口中的方法），作为实现了 Iterable 接口的集合中 iterator() 方法的返回值。 接口 Iterator public interface Iterator&lt;Item&gt; { boolean hasNext(); Item next(); void remove();} 迭代器 ReverseArrayIterator private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { return i &gt; 0; } @Override public Item next() { if (i == 0) throw new NoSuchElementException(); return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); }} 我们这里没有给出 remove() 方法的实现，因为我们希望避免在迭代中穿插能够修改数据结构的操作。这个类是实现在栈类的一个嵌套类中（栈类可以是上面提到的类 FixedCapacityStack ），我们来重写一下这个栈类： import java.util.Iterator;import java.util.NoSuchElementException;public class FixedCapacityStack&lt;Item&gt; implements Iterable { private Item[] a; private int N; public FixedCapacityStack(int cap) { a = (Item[]) new Object[cap]; } private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) temp[i] = a[i]; a = temp; } @Override public Iterator&lt;Item&gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { return i &gt; 0; } @Override public Item next() { if (i == 0) throw new NoSuchElementException(); return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); } } public boolean isEmpty() { return N == 0; } public int size() { return N; } public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item; } public Item pop() { Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; }} 如果不想让 ReverseArrayIterator 作为这个栈类的嵌套类，你也可以单独新建一个类来实现这个迭代器。但要注意的是，ReverseArrayIterator 实现了 Iterator 接口的同时实现了 next() 方法，这个方法拥有一个泛型的返回值。所以我们要这样去定义这个类： public class ReverseArrayIterator&lt;Item&gt; implements Iterator&lt;Item&gt; {...} 其实在你在试过之后就会发现这样是不行的，因为在这个迭代器中使用到了栈类中的数据（存储栈中元素的数组和这个数组所存元素个数）。所以还是就让它做栈类的嵌套类吧！ 另外要注意的就是 Iterable 在 java.lang 中，而 Iterator 在 java.util 中（因为某些历史原因）。 算法 1.1 是 Stack API 的一种能够动态改变数组大小的实现， 它几乎达到了任意集合类数据类型的实现的最佳性能： 每项操作的用时都与集合大小无关； 空间需求总是不超过集合大小乘以一个常数。 缺点在于某些 push() 和 pop() 操作会调整数组的大小：这项操作的耗时和栈大小成正比。我们会学习克服该缺陷的办法，使用一种不同的方式来组织数据。 算法 1.1&emsp;下压（LIFO）栈（能够动态调整数组大小的实现）import java.util.Iterator;import java.util.NoSuchElementException;public class ResizingArrayStack&lt;Item&gt; implements Iterable { private Item[] a = (Item[]) new Object[1]; private int N = 0; public boolean isEmpty() { return N == 0; } public int size() { return N; } private void resize(int max) { Item[] temp = (Item[]) new Object[max]; for (int i = 0; i &lt; N; i++) { temp[i] = a[i]; } a = temp; } public void push(Item item) { if (N == a.length) resize(2 * a.length); a[N++] = item; } public Item pop() { Item item = a[--N]; a[N] = null; if (N &gt; 0 &amp;&amp; N == a.length / 4) resize(a.length / 2); return item; } @Override public Iterator&lt;Item&gt; iterator() { return new ReverseArrayIterator(); } private class ReverseArrayIterator implements Iterator&lt;Item&gt; { private int i = N; @Override public boolean hasNext() { if (i == 0) throw new NoSuchElementException(); return i &gt; 0; } @Override public Item next() { return a[--i]; } @Override public void remove() { throw new UnsupportedOperationException(); } }} PS: 好像跟我们之前写的那个没有什么不同 😅 3. 链表链表是一种递归的数据结构，他或者为空（null），或者指向一个结点（node）的引用，该结点含有一个泛型的与与元素和一个指向另一条链表的引用。 结点记录我们可以在嵌套类中定义结点的抽象数据类型。 private class Node { Item item; Node next;} 我们会通过 new Node() 触发无参的构造方法来创建一个 Node 类型的对象，它会是一个实例化变量初始为 null 的指向某个 Node 对象的引用。这种类型的类有时也被称为记录。 构造链表我们尝试构造一个含有元素 to、be 和 or 的链表，先为每个元素创造结点： Node first = new Node();Node second = new Node();Node third = new Node(); 我们在 item 域中存放 String 类型的数据： first.item = \"to\";second.item = \"be\";third.item = \"or\"; 再设置 next 域来构造链表： first.next = second;second.next = third; 这里 third.next 还是 null 的值，也就是说 third 指向的是 null ，我们看这个图： 链表表示的是一列元素，它与数组的区别就在于：在链表中向序列插入和删除元素更为方便。 在表头插入结点两种方式： 创建一个结点，将它的 next 域设置为 first； 将 first 保存在 oldfirst 中，再将一个新结点赋予 first ，这里我们用 first 的 item 域存放 “not” ，把它的 next 域设置为 oldfirst ：Node oldfirst = first;first = new Node();first.item = \"not\";first.next = oldfirst; 从表头删除结点我们使 first 指向 first.next ，这样改变了 first 的值（变成了之前 first.next 结点对象的一个引用），就无法访问它曾经指向的结点了。曾经的结点对象变成了一个孤儿，Java 的内存管理系统最终将回收它所占用的内存。 first = first.next; 这条赋值语句的运行时间和链表的长度无关。 在表尾插入结点类似于在表头插入结点，还是两种方式： 创建一个结点，将之前的 last 结点的 next 域设置为这个结点； 将之前的 last 保存在 oldlast 中，设置 oldlast 的 next 域为 last ，再将一个新结点赋予 last ，这里我们用 last 的 item 域存放 “not” ：Node oldlast = last;last = new Node();last.item = \"not\";oldlast.next = last; PS: 这里需要强调一点，和在表头插入结点相同，我们创建了一个结点 oldxxx 来保存 xxx ，就是复制了一个 xxx 对象的引用 oldxxx 指向 xxx 对象的地址，相当于创建了一个别名，而不是单纯的值复制，如此一来就有 oldxxx 和 xxx 同时指向同一个对象（我们 前面 有提到过只有原始数据类型是值的复制，其他都复制的是对象的引用）。然后我们又使用 new 关键字来更新 xxx 对象，是重新为 xxx 分配了内存空间，而之前的内存空间并没有被弃用，所以不会被系统回收。 其他位置的插入和删除操作例如，我们要删除链表的尾结点就需要将它的前一个结点的 next 域设置为 null 。但我们没有其他的信息来找出这个位置，所以唯一的办法就是遍历整条链表并找出指向 last 的结点，如此所需的时间就同链表的长度成正比了。 实现任意插入和删除操作的标准解决方案就是使用 双向链表 ，每一个结点都有两个链接指向不同的方向。详见 练习 1.3.31 。 遍历我们可以这样来实现链表的迭代访问： for (Node x = first; x != null; x = x.next()) { x.item } 栈的实现在进行 push() 操作时，我们将元素添加在表头；当使用 pop() 删除一个元素时，我们将它从表头删除。 链表的使用可以达到最优设计目标： 可以处理任意类型的数据； 所需空间总是和集合大小成正比； 操作所需时间与集合大小无关。 算法 1.2&emsp;下压堆栈（链表实现）import java.util.Iterator;public class Stack&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } private void push(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; N++; } private Item pop() { Item item = first.item; first = first.next; N--; return item; }} 自己动手写一个测试用例吧！ 队列的实现在结构化储存数据集时，链表是数组的一种重要的替代方式 。 算法 1.3&emsp;先进先出队列import java.util.Iterator;public class Queue&lt;Item&gt; implements Iterable { private Node first; private Node last; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } public void enqueue(Item item) { Node oldLast = last; last.item = item; if (isEmpty()) first = last; else oldLast.next = last; } public Item dequeue() { Item item = first.item; first = first.next; if (isEmpty()) last = null; N--; return item; }} 自己动手写一个测试用例吧！ 背包的实现算法 1.4&emsp;背包import java.util.Iterator;public class Bag&lt;Item&gt; implements Iterable&lt;Item&gt; { private Node first; private int N; @Override public Iterator&lt;Item&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator&lt;Item&gt; { private Node current = first; @Override public boolean hasNext() { return current != null; } @Override public Item next() { Item item = current.item; current = current.next; return item; } @Override public void remove() { // 这里是接口里默认实现的方法，展示出来 throw new UnsupportedOperationException(\"remove\"); } } private class Node { Item item; Node next; } public boolean isEmpty() { return first == null; } public int size() { return N; } private void add(Item item) { Node oldFirst = first; first = new Node(); first.item = item; first.next = oldFirst; N++; }} 背包的链表实现就是 Stack 去掉 pop() 方法，再将它的 push() 更名为 add() 。 4. 综述 这些数据类型是其他高级数据结构的基础； 它们展示了满足性能目标所带来的挑战； 重点要支持对对象集合的强大操作。 数据结构数组和链表常被称为顺序存储和链式存储。 预告 二叉树的数据结构是含有两个链接的结点组成； 复合型数据结构：用背包储存栈，用队列储存数组； 我们可以用数组的背包来表示图。 数据结构 优点 缺点 数组 通过索引可以直接访问任意元素 在初始化时就需要知道元素的数量 链表 使用的空间和元素数量成正比 需要通过引用访问任意元素 使用抽象想数据类型解决问题： 定义 API； 根据特定场景开发用例代码； 描述一种数据结构，根据 API 定义类的实例变量； 描述算法，根据它实现类中的实例方法； 分析算法的性能特点。 知识点+ 除了使用泛型，我们还可以构造一个 Object 对象的栈，并在 pop() 时将对象转换为所需类型。问题就是类型不匹配的错误只能在运行时发现，而使用泛型则会得到一个编译错误。 Java 中泛型数组：先了解 协变数组（convariant array）和 类型擦除（type erasure）。 创建一个字符串栈的数组（需要进行类型转换） Stack&lt;String&gt;[] a = (Stack&lt;String&gt;[]) new Stack[N]; 在我们写的代码中，栈为空时调用 pop() 会得到一个 NullPointerException 异常。 用例在迭代中调用 push() 或 pop() ，Stack 的迭代器会立即抛出一个 java.util.ConcurrentModificationException 异常。 String 没有实现 Iterable 接口，不能使用 foreach 循环访问。 习题见 习题 1-3","link":"/independent-pages/list/algs4/1/1.3/index.html"}],"posts":[{"title":"《算法（第4版）》知识点归纳解读 + 习题解析","text":"这篇博客主要来记录自己在书中总结归纳的知识点，来帮助自己和大家更好地记忆书中的内容，并在复习时有一个可以参考的大纲。我在每个小节的后面也有附上习题的解答（因为想要加快一下学习进度，顺便巩固所学知识，提高题和实验题会在每章更新完毕之后再加进来）。部分解题代码用到了书中提供的类库，VS Code、 IDEA 等编辑器或编译器内置了快捷跳转至源码位置的操作，读者可以根据自身情况进行参考。另附本书配套的 在线 API 文档 、源码 ，以及下载链接 algs4.jar 、algs4-data.zip 。 ‼️ 更新速度： 周一更新内容，周三更新习题，在每章更新完毕后用两周的时间来添加提高题和实验题的解答。 部分习题答案是可以在 官网 上找到的。另外在 GitHub 上有一个分享自己解题代码的仓库，很详细，值得参考，见 Algorithms 。 PS: 本文中的大部分内容来自于《算法（第4版）》一书，想要了解的同学可以参阅 豆瓣读书 ，另见 英文版 。 第 1 章&emsp;基 础&emsp;&emsp;1.1&emsp;基础编程模型&emsp;&emsp;1.2&emsp;数据抽象&emsp;&emsp;1.3&emsp;背包、队列和栈&emsp;&emsp;1.4&emsp;算法分析&emsp;&emsp;1.5&emsp;案例研究：union-find 算法 第 2 章&emsp;排 序&emsp;&emsp;2.1&emsp;初级排序算法&emsp;&emsp;2.2&emsp;归并排序&emsp;&emsp;2.3&emsp;快速排序&emsp;&emsp;2.4&emsp;优先队列&emsp;&emsp;2.5&emsp;应用 第 3 章&emsp;查 找&emsp;&emsp;3.1&emsp;符号表&emsp;&emsp;3.2&emsp;二叉查找树&emsp;&emsp;3.3&emsp;平衡查找树&emsp;&emsp;3.4&emsp;散列表&emsp;&emsp;3.5&emsp;应用 第 4 章&emsp;图&emsp;&emsp;4.1&emsp;无向图&emsp;&emsp;4.2&emsp;有向图&emsp;&emsp;4.3&emsp;最小生成树&emsp;&emsp;4.4&emsp;最短路径 第 5 章&emsp;排 序&emsp;&emsp;5.1&emsp;字符串排序&emsp;&emsp;5.2&emsp;单词查找树&emsp;&emsp;5.3&emsp;子字符串查找&emsp;&emsp;5.4&emsp;正则表达式&emsp;&emsp;5.5&emsp;数据压缩 第 6 章&emsp;背 景&emsp;&emsp;6.0&emsp;背景","link":"/algs4/"},{"title":"关于 VS Code 中 \"Classpath is incomplete\" warning","text":"问题概述每当打开一个 java 文件时，它不属于项目（我们称之为独立的 java 文件），vscode-java 无法计算正确的类路径。它使报告编译错误变得毫无用处，因为 UI 会在整个文件中填充令人分心的红色错误，例如： 幸运的是，vscode-java 仍然能够为基本 JDK 类提供有用的内容辅助，报告语法错误，计算类大纲或允许代码导航。因此，显示以下警告： 如果您只是关闭消息，它将在下次打开独立的 java 文件时弹出。通过单击Don’t Show Again 选项，可以永久地丢弃该消息。 如果改变主意，可以在 VS Code 的用户设置中修改该选项：java.errors.incompleteClasspath.severity 键指定当 java 文件的类路径不完整时消息的严重性。支持的值包括 ignore, info, warning 和 error。 您需要打开一个包含 pom.xml, build.gradle 或至少是默认 eclipse 设置文件的文件夹，以便可以设置完整的类路径和项目层次结构。 Android 项目基于 Gradle 的 Android 项目目前显示此消息，因为目前不支持 Android 开发。这是 limitation of BuildShip，该项目提供 Gradle 支持。 参考：https://github.com/redhat-developer/vscode-java/wiki/%22Classpath-is-incomplete%22-warning","link":"/vscode-warning-classpath-is-incomplete/"},{"title":"同一客户端下使用多个 Git 账号","text":"我们在日常使用 Git 进行文件管理时，避免不了会使用多个账号的情况。自己在家开发一些小项目就托管在 Github 上面，而在公司的话会用到另外一个账号，可能是 GitLab 账号进行管理，或者是自己想要搭建一个个人博客并托管在另一个账号，那么单纯的 HTTPS 就不足以支持两个账号在同一客户端进行使用了，这时就需要用到 SSH 来进行管理。 PS: 这篇博客主要是想要记录自己多个 Git 账号的配置过程，以备查阅。 1. 清除 Git 的全局设置git config --global --unset user.namegit config --global --unset user.email 2. 生成新的 SSH keys用 ssh-keygen 命令生成一组新的 id_rsa_new 和 id_rsa_new.pubssh-keygen -t rsa -C \"new email\" 在生成第一组 id_rsa 和 id_rsa.pub_ 可以选用默认的文件名，在出现提示输入文件名的时候要输入一个不同的文件名，比如： 这里填的是 id_rsa_new Enter file in which to save the key (~/.ssh/id_rsa): id_rsa_new 注： Windows 用户和 Mac 用户的区别就是，mac 中 .ssh 文件夹在根目录下，所以表示成 ~/.ssh/，而 Windows 用户是 C:\\Users\\Administrator\\.ssh。 执行 ssh-agent 让 ssh 识别新的私钥因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中： ssh-add ~/.ssh/id_rsa_new 如果出现 Could not open a connection to your authentication agent 的错误，就试着用以下命令： ssh-agent bashssh-add ~/.ssh/id_rsa_new ssh-add ~/.ssh/id_rsa_new 只能将把指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。 解决办法就是在添加 ssh 私钥的时候使用如下命令：ssh-add -K privateKey，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。 参考博客：http://www.icodeyou.com/2016/01/17/ssh-add-mac/ 3. 配置 ~/.ssh/config 文件# 该文件用于配置私钥对应的服务器Host git@github.com # 别名，随便定 后面配置地址有用 HostName https://github.com User git IdentityFile ~/.ssh/id_rsa # 密钥文件的地址，注意是私钥# second user(second@mail.com)Host git@code.xxxxxxx.com HostName https://code.xxxxxxx.com User git IdentityFile ~/.ssh/id_rsa_new PS: HostName 如果添加 https:// 前缀可能发生 public key 不能识别的情况，所以可以直接改为 github.com 4. 添加新的 SSH keys 到新账号的 SSH 设置中5. 测试一下$ ssh -T git@github.com # 此处是 Host 后面定义的别名Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.# 上面是 github 的成功返回语句，下面是 gitlab 的成功返回语句。$ ssh -T git@xxxxxx.comWelcome to GitLab, xxx! 链接：https://www.jianshu.com/p/89cb26e5c3e8/来源：简书 参考资料https://blog.csdn.net/onTheRoadToMine/article/details/79029331/ https://gist.github.com/suziewong/4378434/","link":"/git-one-more-account/"},{"title":"Hanoi 塔问题在 C++ 中的递归实现","text":"Hanoi 塔问题想必是很多同学在大一都会接触到的，它是一个很经典的算法问题，这里主要阐释 Hanoi 问题在 C++ 中的递归实现。当然你也可以查阅一些其他资料来理解它的非递归实现过程，这里就不再叙述了。有兴趣的同学可以参考：迭代式汉诺塔(利用栈实现非递归) &emsp; 汉诺塔问题的递归和非递归算法 本文意旨解决“为何圆盘的移动的位置不对？”的问题，用两组代码来分析圆盘的移动位置。 PS: 当然，如果想更好地理解这篇博客，就需要你在阅读之前对 Hanoi 塔问题有一个清晰的了解。如果你还不知道什么是 Hanoi 塔问题，请移步 百度百科。 开始分析1. 先来看一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 b 柱将圆盘全部移到 c 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucers: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 hanoi(n - 1, b, a, c); // 将第 n-1个圆盘从 b柱借助 a柱移动到 c柱} 如果你之前有成功实现过hanoi塔从 a 移动到 c (a ⟹ c) 的递归算法，应该很容易就能看懂。但是你试过将圆盘从 a 柱全部移动到 b 柱上的情况吗？ 如果你已经清楚了代码的含义，那么你可以试着实现另外的几种情况 a ⟹ b b ⟹ c c ⟹ a c ⟹ b 2. 再来看另一组示例代码在此代码块中，n 代表圆盘的个数，需要通过键盘输入。开始时圆盘都位于 a 柱，期间借助 c 柱将圆盘全部移到 b 柱 #include &lt;iostream&gt;int main() { void hanoi(int n, char a, char b, char c); int n; std::cout &lt;&lt; \"input the number of saucer: \"; std::cin &gt;&gt; n; hanoi(n, 'a', 'b', 'c'); return 0;}void hanoi(int n, char a, char b, char c) { if (n == 1) { std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; return; } hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 hanoi(n - 1, c, b, a); // 将第 n-1个圆盘从 c柱经由 a柱移动到 b柱} 你可能会觉得两组代码在实现上没什么差别，那我们来看两组代码其中一行的对照： hanoi(n - 1, a, c, b); // 将第 n-1 个圆盘从 a 柱借助 c 柱移动到 b 柱 hanoi(n - 1, a, c, b); // 将第 n-1个圆盘从 a柱经由 b柱移动到 c柱 我们可以发现，两组代码中这一行代码都是相同的，但为什么实现的操作是不一样的呢？ 3. 其中两行代码的对比std::cout &lt;&lt; \"move \" &lt;&lt; n &lt;&lt; \" from \" &lt;&lt; a &lt;&lt; \" to \" &lt;&lt; c &lt;&lt; std::endl; // 将第 n个圆盘从 a柱直接移动到 c柱 std::cout &lt;&lt; n &lt;&lt; \": \" &lt;&lt; a &lt;&lt; \" --&gt; \" &lt;&lt; b &lt;&lt; std::endl; // 将第 n个圆盘直接移动到 b柱 我们可以看到第一行代码时从 a位置 指向 c位置，第二行代码则是从 a位置 指向 b位置， 而第一行代码中的 “a位置” 和 “c位置” 对应了第一组代码 hanoi(n - 1, a, c, b); 中的 c 和 b，第二行代码中的 “a位置” 和 “b位置”对应了第二组代码 hanoi(n - 1, a, c, b); 中的 c 和 b 整组代码中实现输出是依靠 输出流语句，所以 hanoi(n - 1, a, c, b); 中的字母顺序要根据 输出流语句 的变化而变化以达到正确调用递归的目的。 也是大一刚开始接触编程语言，希望我的分享能给大家带来帮助 (｡･∀･)ﾉﾞ 到这里如果你还没有弄明白，这里能以图的形式更直观地理解 Hanoi 塔问题的递归实现，请参考：汉诺塔的图解递归算法","link":"/hanoi-cpp/"},{"title":"Emacs Note","text":"这是一个 Emacs 的学习笔记，用来记录一些重要的知识点，以便于帮助自己进行回顾。笔记的大部分内容来自于 Spacemacs Rocks 第二季 的课程。 参见：&emsp; &emsp; 子龙山人：Master Emacs in 21 Days&emsp; &emsp; 视频教程：优酷 &emsp; 百度网盘 &emsp; YouTube 在 Emacs 中使用 C-h t 打开 Emacs Tutorial ，完成官方教程 1. 基础操作常见的符号意义： C(trl) 在 Mac 上为 Control 键 M(eta) 在 Mac 上为 Option 键 s(uper) 在 Mac 上为 Command 键 S(hift) 光标的移动： C-f 为前移一个字符， f 代表 forward C-p 为上移至前一行， p 代表 previous C-n 为上移至下一行， n 代表 next C-a 为移至行首， a 代表 ahead C-e 为移至行尾， e 代表 end 常用的文件操作： C-x C-f 为打开目标文件 f 代表 find / file C-x C-s 为保存当前缓冲区（Buffer）， s 代表 save C-x C-e 快捷键就是按预先绑定好的方式执行命令相似的前缀命令还有 C-c、C-h 2. 内置功能 M-x linum-mode 开启编辑器内的行号显示 3. 学习 Elisp 基础阅读教程 Learn X in Y minutes ，或参见 中文版 ;; 2 + 3 * 4(+ 2 (* 3 4))(setq my-name \"Mark\")(message my-name)(defun my-func () ;; Specify a way of parsing arguments for interactive use of a function. (interactive) (message \"Hello, %s\" my-name))(global-set-key (kbd \"&lt;f2&gt;\") 'my-func) 4. 简单的编辑器自定义Emacs 的配置文件默认保存在 ~/.emacs.d/init.el 文件中，也可以保存在 ~/.emacs 文件中。 如果将配置放在 ~/.emacs.d/init.el 文件中，需要手动删除 ~/.emacs 文件。 ;; 关闭工具栏，tool-bar-mode 是一个 Minor Mode(tool-bar-mode -1);; 关闭文件滑动控件(scroll-bar-mode -1);; 显示行号(global-linum-mode 1);; 更改光标的样式(golbal-setq cursor-type 'bar);; 关闭启动帮助画面(setq inhibit-splash-screen 1);; 关闭缩进;; (electric-indent-mode -1);; 更改显示字体大小 16pt;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs(set-face-attribute 'default nil :height 160);; 快速打开配置文件(defun open-init-file() (interactive) (find-file \"~/.emacs.d/init.el\"));; 这一行代码，将函数 open-init-file 绑定到 &lt;f2&gt; 键上(global-set-key (kbd \"&lt;f2&gt;\") 'open-init-file) 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加载配置文件。重新加载配置文件你需要在当前配置文件中使用 M-x load-file 双击两次回车确认默认文件名，或者使用 -x eval-buffer 去执行当前缓冲区的所有 Lisp 命令。 你也可以使用 C-x C-e 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效. 5. 插件管理使用默认的插件管理系统（在菜单栏 Options &gt; Manage Emacs Packages 中找到）安装 Company 插件，是一个用于代码补全的插件。它的名字代表补全一切的意思（ Comp lete Any thing）。 ;; 开启全局 Company 补全(global-company-mode 1) 6. Org-mode分级标题* 为一级标题** 为二级标题*** 为三级标题并以此类推 作为 GTD 工具进行时间管理C-c C-t 切换 TODO -&gt; DONE -&gt; NONE","link":"/emacs-note/"},{"title":"Mac 上好用的 APP 整理","text":"我整理了一些自己平常在 Mac 上经常用到的 APP，大家可以参考一下。另外我提供了项目网站和下载页面的地址。 文本编辑：Atom Atom 是由 GitHub 专门为程序员推出的跨平台文本编辑器，支持 CSS，HTML，JavaScript 等网页编程语言。 Emacs Emacs 是被公认为程序员最喜爱的代码编辑器之一，另外一个是 Vim。Emacs 使用 Emacs Lisp 这种极具扩展性的编程语言，实现了包括编程、编译乃至网络浏览等功能的扩展。 Sublime Text 3 Sublime Text 是一款流行的代码编辑器软件，也是HTML和散文先进的文本编辑器，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 MacDown MacDown 是一款 Mac 下的 Markdown 编辑器。由于 Mou 的作者曾宣布不再继续该软件的开发并寻求出售所有权，所以 Macdown 的作者决定自己开发，MacDown 的很大一部分受到了 Mou 的影响。 效率工具：Alfred Alfred 是 Mac 下最流行的提升效率的工具。 AppCleaner AppCleaner 是 macOS 上的超轻量卸载专家。 Magnet Magnet 是 macOS 上进行窗口管理的快捷工具。 Pock Pock 是一款 macOS App，你可以通过它把 Touch Bar 变成系统中的 Dock 栏，直接用来切换和启动 App。 QSpace QSpace 是一款简洁高效的多视图文件管理器。 Sip Sip 是 macOS 上一款非常不错的取色软件。 清理工具：Tencent Lemon Tencent Lemon 是 macOS 上的一款清理软件，在 AppStore 上提供 Lite 版本的下载。 播放器：IINA IINA 是一个现代的 macOS 视频播放器。 通讯：Telegram Telegram 是一款跨平台的实时通讯软件。 云盘：Mega Mega 是一款云储存服务，免费版账户提供 35G 的云储存空间。 Seafile Seafile 是一款开源的企业云盘，注重可靠性和性能。支持 Windows, Mac, Linux, iOS, Android 平台。支持文件同步或者直接挂载到本地访问。普通用户提供 2GB 的储存空间。 VPN 服务Windscribe Windscribe 是一款跨平台的 VPN 服务，普通用户每月有 10GB 的免费流量。","link":"/awesome-mac-apps/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hanoi","slug":"Hanoi","link":"/tags/Hanoi/"},{"name":"Emacs","slug":"Emacs","link":"/tags/Emacs/"},{"name":"Elisp","slug":"Elisp","link":"/tags/Elisp/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"笔记","slug":"Java/笔记","link":"/categories/Java/笔记/"},{"name":"笔记","slug":"笔记","link":"/categories/笔记/"},{"name":"开发工具","slug":"Git/开发工具","link":"/categories/Git/开发工具/"},{"name":"算法","slug":"C/算法","link":"/categories/C/算法/"}]}